\documentclass[sigconf]{acmart}

% ===================== Packages =====================
\usepackage[T1]{fontenc}
\usepackage{mathtools}
\usepackage{microtype}

\usepackage{amsmath,amssymb,amsthm}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{graphicx}   % for \resizebox (fit-to-column helpers)

% Helpers: scale only when needed
\newcommand{\fitcol}[1]{\resizebox{\columnwidth}{!}{$\displaystyle #1$}}
\newcommand{\fitcoltext}[1]{\resizebox{\columnwidth}{!}{$#1$}}

% ===================== Visible "bold" (robust under broken bold fonts) =====================
% If your TeX setup is missing the bold font shapes used by acmart, \textbf/\bfseries can look unchanged.
% These macros force Computer Modern Sans Bold Extended (cmss/bx), which is essentially always available.
\DeclareRobustCommand{\kfeat}[1]{{\fontfamily{cmss}\fontseries{bx}\selectfont #1}}
\DeclareRobustCommand{\khead}[1]{{\fontfamily{cmss}\fontseries{bx}\selectfont #1}}

% ===================== Theorems =====================
\usepackage{amsthm}

\newtheoremstyle{pbplain}
  {6pt}{6pt}{\itshape}{0pt}{} {.}{0.6em}
  {\khead{\thmname{#1}\thmnumber{ #2}}\thmnote{ \khead{(#3)}}}

\newtheoremstyle{pbdef}
  {6pt}{6pt}{\normalfont}{0pt}{} {.}{0.6em}
  {\khead{\thmname{#1}\thmnumber{ #2}}\thmnote{ \khead{(#3)}}}

\theoremstyle{pbdef}
\newtheorem{definition}{Definition}[section]
\newtheorem{remark}{Remark}[section]

\theoremstyle{pbplain}
\newtheorem{proposition}{Proposition}[section]
\newtheorem{corollary}{Corollary}[section]

% ===================== Operators =====================
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\dom}{dom}

% ===================== ACM Metadata / Suppression =====================
\settopmatter{printacmref=false}
\setcopyright{none}
\renewcommand\footnotetextcopyrightpermission[1]{}

\acmDOI{}
\acmISBN{}
\acmConference{}{}{}
\acmBooktitle{}
\acmYear{}

% Provide a short title without line breaks for PDF metadata
\title[PB CNS Settlement Allocation System]{PB CNS Settlement Allocation System: Security-ID Partitioning, Exactly-Once Publication, and Crash Recovery}

% Full (typeset) title can still contain line breaks
\title{PB CNS Settlement Allocation System\\
with Security-ID Partitioning, Exactly-Once Publication, and Crash Recovery}

\author{}
\affiliation{%
  \institution{}
  \city{}
  \country{}
}
\date{}

\begin{document}

% ===================== ABSTRACT =====================
\begin{abstract}
This document formally specifies a PB (PB) settlement allocation system as a labeled transition system (LTS).
The system handles Continuous Net Settlement (CNS) obligations by allocating settled securities flows across client trades,
covering both receive- and deliver-side settlement using a signed-quantity convention.
Key features include: \kfeat{Security-ID partitioning} for parallel processing,
\kfeat{pluggable allocation strategies},
\kfeat{exactly-once publication} guarantees to downstream lending systems,
\kfeat{crash recovery via transactional processing over a durable ordered message log},
\kfeat{partial-settlement support},
and a special case where a trade may be \kfeat{sent to CNS but ultimately settles broker-to-broker} with settlement confirmed by an external system.
The formal model enables rigorous reasoning about correctness, fault tolerance, and progress properties.
\end{abstract}

\maketitle
\pagestyle{plain}

% ===================== INTRODUCTION =====================
\section{Introduction and Overview}

In PB operations, securities settlement through Continuous Net Settlement (CNS)
systems presents complex challenges. The prime broker acts as a single participant in CNS,
receiving netted obligations for each security. Simultaneously, the PB services numerous
clients whose individual trades must be settled using the securities received from or delivered into CNS.
This document specifies a system that bridges these two worlds: it allocates CNS-settled
quantities across client trades according to \kfeat{configurable (pluggable) strategies},
handles \kfeat{partial settlements}, ensures \kfeat{exactly-once publication} of allocations to
downstream lending systems, and maintains consistency via \kfeat{crash recovery} even in the face
of failures.

\paragraph{Special case: CNS bypass settlement.}
In some flows, a trade may be routed to CNS but not settle in CNS; instead, the trade settles \emph{broker-to-broker}
outside CNS and an external system later notifies the PB of that settlement.
This model represents such events as an additional source of allocatable settlement supply that
\emph{does not change} the CNS obligation state $O_s$, but \emph{does change} the settlement carry available for allocation.

\subsection{Core Challenges and Solutions}

\begin{enumerate}[leftmargin=*]
  \item \khead{Partitioning for Scalability}: Processing is partitioned by \kfeat{security identifier}, allowing independent and parallel processing per security while preserving correctness.
  \item \khead{Exactly-Once Semantics}: Allocations published to lending systems must not be duplicated or lost, even during retries after \kfeat{crashes}.
  \item \khead{Partial Settlement Support}: The system must handle cases where only \kfeat{partial quantities} of securities are available for allocation across client trades.
  \item \khead{Crash Recovery}: The system recovers deterministically using \kfeat{transactional commits} against a \kfeat{durable ordered message log}: state updates, output publication, and advancement of the input cursor occur atomically, so crashes do not lose committed progress.
  \item \khead{End-of-Day Reconciliation}: The system must reconcile allocated quantities with CNS obligations and (when present) broker-to-broker settlement notifications to identify discrepancies.
\end{enumerate}

\subsection{Modeling Approach}

\begin{enumerate}[leftmargin=*]
  \item Define the global system as a product of per-security shards (Section~\ref{sec:partitioned-lts})
  \item Specify per-shard state and transitions (Section~\ref{sec:per-shard})
  \item Establish correctness invariants and safety properties (Section~\ref{sec:safety})
  \item Prove exactly-once publication and crash recovery guarantees (Section~\ref{sec:exactly-once})
  \item Define fairness and progress properties (Section~\ref{sec:fairness})
  \item Demonstrate end-of-day convergence (Section~\ref{sec:reconciliation})
\end{enumerate}

% ===================== DOMAINS =====================
\section{Domains and Notation}
\label{sec:domains}

\subsection{Sets and Types}

\begin{itemize}[leftmargin=*]
  \item $S$ : finite set of security identifiers (partition keys).
  \item $C$ : finite set of client identifiers.
  \item $T$ : finite set of trade identifiers.
  \item $ID$ : finite set of allocation identifiers.
  \item $EID$ : finite (or countable) set of external-settlement event identifiers (for idempotence).
  \item $\mathbb{Z}$ : integers (positive, negative, and zero).
  \item $\mathbb{Z}_{\ge 0}$ : non-negative integers.
\end{itemize}

\subsection{Trade Representation}

Each trade $t \in T$ represents a client transaction requiring settlement. Trades have immutable attributes recorded at creation:
\[
\begin{aligned}
client(t) &\in C, &&\text{the client who executed the trade}\\
sec(t) &\in S, &&\text{the security being traded}\\
qty^{tot}(t) &\in \mathbb{Z}, &&\text{total quantity to be settled}
\end{aligned}
\]
\hfill\break
(signed: $>0$ receive, $<0$ deliver)

\paragraph{Quantity sign and direction.}
Trade and allocation quantities in this model use a \emph{signed} convention:
$qty^{tot}(t)>0$ denotes a receive trade (PB is due to receive securities),
and $qty^{tot}(t)<0$ denotes a deliver trade (PB is due to deliver securities).
CNS obligations (below) use the same signed convention.

The system tracks allocated quantity per trade:
\[
\begin{aligned}
qty^{alloc}(t) &\in \mathbb{Z},
\qquad
qty^{alloc}(t)\cdot qty^{tot}(t)\ge 0,
\qquad \\
|qty^{alloc}(t)| &\le |qty^{tot}(t)|.
\end{aligned}
\]
Open (unallocated) quantity is:
\[
qty^{open}(t) \triangleq qty^{tot}(t) - qty^{alloc}(t).
\]
Thus $qty^{open}(t)$ has the same sign as $qty^{tot}(t)$ (or is $0$), and decreases toward $0$ as settlement is allocated.

\subsection{CNS Obligations and Settlement Supply}

CNS messages may cover multiple securities, so we model them as partial maps:
\[
M : S \rightharpoonup \mathbb{Z}.
\]

For each security $s \in S$, CNS provides the PB's net open obligation $O(s)\in\mathbb{Z}$.
A positive $O(s)$ indicates CNS owes securities to PB (receive), while negative indicates PB owes CNS (deliver).
The same sign convention applies to each $M(s)$ when present.

\paragraph{Settlement flow induced by obligation changes.}
The allocatable settled flow for security $s$ induced by an obligation update is:
\[
\Delta settle(s) \triangleq
\begin{cases}
O_{prev}(s)-O_{new}(s),
& \begin{aligned}
  &\text{if } \sgn(O_{prev}(s))=\sgn(O_{new}(s))\\
  &\wedge\ |O_{new}(s)|<|O_{prev}(s)|
\end{aligned}
\\[2pt]
O_{prev}(s),
& \text{if } \sgn(O_{prev}(s))\neq \sgn(O_{new}(s)),\\
0, & \text{otherwise.}
\end{cases}
\]
A positive $\Delta settle(s)$ means PB \emph{received} securities; a negative value means PB \emph{delivered} securities.

\paragraph{External (broker-to-broker) settlement supply.}
In the CNS-bypass special case, an external system notifies that settlement has occurred broker-to-broker for security $s$.
We model each such notification as an event with a unique identifier $eid\in EID$ and a signed quantity $x\in\mathbb{Z}$.
This contributes allocatable settlement supply but \emph{does not} change the CNS obligation $O(s)$.

% ===================== PARTITIONED LTS =====================
\section{System as a Partitioned Labeled Transition System}
\label{sec:partitioned-lts}

\subsection{Per-Security Shards}

For each security $s \in S$, define a per-security shard as a labeled transition system:
\[
\mathcal{PB}_s = (\mathcal{S}_s, \mathcal{A}_s, \rightarrow_s, \sigma_{0,s}),
\]
where $\rightarrow_s \subseteq \mathcal{S}_s \times \mathcal{A}_s \times \mathcal{S}_s$.

\subsection{Global System Composition}

The global system is the product of all shards:
\[
\mathcal{PB} =
\left(\prod_{s\in S}\mathcal{S}_s,\ \mathcal{A},\ \rightarrow,\ \prod_{s\in S}\sigma_{0,s}\right).
\]

\subsection{Global Event Routing and Demultiplexing}

Let $\mathcal{E}$ be the set of all incoming events/messages. Each event $e\in\mathcal{E}$ has a security routing key:
\[
key : \mathcal{E} \rightarrow S.
\]

\khead{Routing Rules:}
\begin{itemize}[leftmargin=*]
  \item For trade events $\mathsf{CLIENT\_TRADE}(t)$, $key(\cdot)=sec(t)$.
  \item For publication events $\mathsf{PUBLISH}(id)$, $key(\cdot)=sec(id)$.
  \item For CNS multi-security messages $M:S\rightharpoonup\mathbb{Z}$, ingestion is modeled by demultiplexing into per-security events
        $\mathsf{MSG}_s(M(s))$ for each $s\in \mathrm{dom}(M)$.
  \item For external broker-to-broker settlement events $\mathsf{B2B\_SETTLE}(eid,s,x)$, $key(\cdot)=s$.
\end{itemize}

\khead{Demultiplexing:}
\[
\mathsf{MSG}(M) \equiv \{\, \mathsf{MSG}_s(M(s)) \mid s \in \dom(M)\,\}.
\]

\subsection{Global Transition Relation}

Let the global state be $\sigma = \langle \sigma_s \rangle_{s\in S}$. For any event $e$:
\[
\sigma \xrightarrow{e} \sigma'
\ \text{iff}\
\sigma_{key(e)} \xrightarrow{e}_{key(e)} \sigma_{key(e)}'
\ \wedge\
\forall s'\neq key(e):\ \sigma_{s'}'=\sigma_{s'}.
\]

% ===================== PER-SHARD =====================
\section{Per-Shard State, Actions, and Transitions}
\label{sec:per-shard}

\subsection{Per-Shard State Components}

For a fixed security $s\in S$, shard state:
\[
\sigma_s = (O_s,\ Tr_s,\ A_s,\ U_s,\ B_s,\ D_s,\ P_s,\ K_s,\ \Theta_s).
\]

\begin{itemize}[leftmargin=*]
  \item $O_s\in\mathbb{Z}$: current CNS open obligation for security $s$.
  \item $Tr_s\subseteq T$: set of trades with $sec(t)=s$.
  \item $A_s\subseteq ID_s\times T\times\mathbb{Z}$: allocation ledger, tuples $(id,t,q)$ (signed $q$).
  \item $U_s\in\mathbb{Z}$: unallocated settled-flow carry (signed), from \emph{all} settlement supply sources modeled.
  \item $B_s\in\mathbb{Z}$: cumulative externally-notified broker-to-broker settled flow (signed).
  \item $D_s\subseteq EID$: deduplication set of external settlement event identifiers already applied.
  \item $P_s:ID_s\rightharpoonup\{\mathsf{pending},\mathsf{published}\}$: publication status map.
  \item $K_s\in\mathbb{Z}_{\ge 0}$: durable input cursor (last committed position) for the per-security ordered message stream.
  \item $\Theta_s$: configuration and strategy parameters.
\end{itemize}

\begin{proposition}[Cursor Monotonicity]
For all reachable states, $K_s$ is non-decreasing and increases with each commit of input-driven transitions.
\end{proposition}

\paragraph{Local Identifier Spaces.}
\[
ID = \biguplus_{s\in S} ID_s,
\quad \text{and}\quad
\forall id\in ID_s:\ sec(id)=s.
\]

\subsection{Persistence Model}

All components $(O_s,Tr_s,A_s,U_s,B_s,D_s,P_s,K_s)$ are persistent and survive crashes. Runtime-only structures are volatile and omitted.

\subsection{Initial State}

\[
\sigma_{0,s} = (0,\ \emptyset,\ \emptyset,\ 0,\ 0,\ \emptyset,\ \emptyset,\ 0,\ \Theta_s).
\]

\subsection{Per-Shard Actions}

\begin{equation*}
\mathcal{A}_s \supseteq
\left\{
\vphantom{\sum_{i=1}^{n}}
\begin{aligned}
\mathsf{SOD\_RECON}_s(x),\ &\mathsf{MT570}_s(x),\\
\mathsf{SETTLE\_BATCH}_s(x),\ &\mathsf{CLIENT\_TRADE}_s(t),\\
\mathsf{B2B\_SETTLE}_s(eid,x),\ &\mathsf{ALLOCATE}_s,\\
\mathsf{PUBLISH}_s(id),\ &\mathsf{EOD\_RECON}_s,\\
\mathsf{CRASH}_s,\ &\mathsf{RESTART}_s
\end{aligned}
\right\}
\end{equation*}

where $x\in\mathbb{Z}$, $t\in T$ with $sec(t)=s$, $id\in ID_s$, and $eid\in EID$.

\subsection{Transactional Processing Discipline}

\khead{Atomicity assumption (exactly-once engine):}
For any input-driven action ($\mathsf{MT570}_s(\cdot)$, $\mathsf{SETTLE\_BATCH}_s(\cdot)$, $\mathsf{CLIENT\_TRADE}_s(\cdot)$, $\mathsf{B2B\_SETTLE}_s(\cdot,\cdot)$, $\mathsf{PUBLISH}_s(\cdot)$), the implementation executes a single atomic transaction that:
\begin{enumerate}[leftmargin=*,topsep=0.25em,itemsep=0.15em]
  \item persists the resulting shard state updates ($A_s,U_s,B_s,D_s,P_s,O_s,Tr_s$),
  \item emits the corresponding output message(s) to the downstream lending interface when applicable
        (notably for $\mathsf{CLIENT\_TRADE}_s(t)$ and $\mathsf{PUBLISH}_s(id)$),
  \item and advances the durable input cursor $K_s$ to acknowledge the consumed input record.
\end{enumerate}
If a crash occurs before commit, \emph{none} of these effects become visible; on restart, the system resumes from the last committed $K_s$ and reprocesses remaining input records.

\subsection{Derived Quantities}

\[
Need_s \triangleq \sum_{t \in Tr_s} qty^{open}(t).
\]
This $Need_s$ represents the \emph{net} open settlement demand from all client trades for security $s$ (signed:
receive positive, deliver negative). It guides allocation decisions and appears in the end-of-day reconciliation equation.

% ===================== TRANSITIONS =====================
\subsection{Per-Shard Transition Relation: Detailed Explanations}

The following transitions define the core operational behavior of each security shard. Input-driven transitions are committed transactionally together with cursor advancement as specified above; internal transitions (e.g., $\mathsf{ALLOCATE}_s$) may also be executed transactionally, but do not necessarily advance $K_s$.

\subsubsection{Start-of-Day Reconciliation}

The system reconciles with CNS at start of day to establish the initial obligation position:
\[
\sigma_s \xrightarrow{\mathsf{SOD\_RECON}_s(x)}_s \sigma_s'
\]

\textbf{Processing:} Update the new CNS obligation $x$ for security $s$:
\[
O_s' = x.
\]

\textbf{Purpose:} This establishes the baseline for tracking settlement flow on either side (receive if $x>0$, deliver if $x<0$).

\subsubsection{CNS Updates (MT570, Settle Batch)}

CNS provides updates through MT570 messages or settle batch notifications. These transitions handle changes to CNS obligations:
\[
\sigma_s \xrightarrow{\mathsf{MT570}_s(x)}_s \sigma_s'
\quad\text{or}\quad
\sigma_s \xrightarrow{\mathsf{SETTLE\_BATCH}_s(x)}_s \sigma_s'.
\]

\textbf{Processing:} Compute allocatable settled flow induced by the obligation change:
\[
\delta \triangleq \Delta settle(s)\ \text{with } O_{prev}(s)=O_s,\ O_{new}(s)=x.
\]
Then update carry and obligation:
\[
U_s' = U_s + \delta,
\qquad
O_s' = x.
\]

\textbf{Business Logic:} Allocatable settled flow is created only when $|O_s|$ decreases (or the sign flips, settling the prior side).
Pure increases in $|O_s|$ represent new/expanded obligations and do not create allocatable settled flow.

\subsubsection{External Broker-to-Broker Settlement Notification (CNS Bypass)}

An external system may notify that settlement has occurred broker-to-broker for security $s$:
\[
\sigma_s \xrightarrow{\mathsf{B2B\_SETTLE}_s(eid,x)}_s \sigma_s'
\]

\textbf{Precondition (idempotence/dedup):} $eid\notin D_s$.

\textbf{Processing:} Within a single atomic transaction, record the event id, update cumulative external settled flow,
and add the settled quantity into allocatable carry:
\[
D_s' = D_s \cup \{eid\},
\qquad
B_s' = B_s + x,
\qquad
U_s' = U_s + x,
\qquad
O_s' = O_s.
\]

\textbf{Interpretation:} External settlement creates allocatable supply for allocation (via $U_s$) without changing CNS obligations ($O_s$ remains the CNS truth).

\subsubsection{Client Trade Arrival}

New client trades arrive continuously throughout the day:
\[
\sigma_s \xrightarrow{\mathsf{CLIENT\_TRADE}_s(t)}_s \sigma_s'
\qquad
(sec(t)=s)
\]

\textbf{Precondition:} The trade $t$ must be for security $s$, i.e., $sec(t)=s$.

\textbf{Processing:} Within a single atomic transaction, the system:
\begin{enumerate}[leftmargin=*,topsep=0.25em,itemsep=0.15em]
  \item adds the trade to the shard trade set,
  \item emits a corresponding \emph{trade-arrival} message to the downstream lending interface (keyed by $t$),
  \item and advances the durable input cursor $K_s$ for the consumed $\mathsf{CLIENT\_TRADE}_s(t)$ input record.
\end{enumerate}
Formally, the shard state update is:
\[
Tr_s' = Tr_s \cup \{t\}.
\]

\textbf{Downstream Interface Assumption:} The lending system \emph{should} process trade-arrival messages idempotently by trade identifier $t$ so that any retries outside the transactional boundary are harmless.

\textbf{Note:} The trade's total quantity $qty^{tot}(t)$ is immutable and recorded when the trade is added. Initially, $qty^{alloc}(t)=0$ and $qty^{open}(t)=qty^{tot}(t)$.

\subsubsection{Allocation (Pluggable, Partial)}

This is the core transition where settled flow is allocated to client trades:
\[
\sigma_s \xrightarrow{\mathsf{ALLOCATE}_s}_s \sigma_s'
\]

\textbf{Allocation Strategy Operator Invocation:} Define the open-demand vector over current shard trades:
\[
open_s(t)\triangleq qty^{open}(t)\ (t\in Tr_s),
\qquad
Open_s \in \mathbb{Z}^{Tr_s}.
\]
The system invokes the allocation operator (Section~\ref{sec:alloc-operator}):
\[
X \triangleq \mathcal{F}_{s,\Theta_s}(Tr_s,\ Open_s,\ U_s),
\qquad
X \in \mathbb{Z}^{Tr_s},
\]
where each component $X_t$ is the signed quantity allocated to trade $t$.

\textbf{Feasibility Constraints:} Let $d \triangleq \sgn(U_s)$.
If $d=0$, then $X_t=0$ for all $t$.
Otherwise the plan must satisfy:
\[
\forall t\in Tr_s:\
\begin{cases}
X_t = 0, & \text{if } \sgn(open_s(t))\neq d,\\
0 \le d\cdot X_t \le d\cdot open_s(t), & \text{if } \sgn(open_s(t))=d,
\end{cases}
\]
and the total must respect available carry:
\[
0 \le d\cdot \sum_{t\in Tr_s} X_t \le d\cdot U_s \ (=|U_s|).
\]
Intuitively, receive-side carry ($U_s>0$) is allocated only to receive-open trades, and deliver-side carry ($U_s<0$) only to deliver-open trades.

\textbf{Processing for Nonzero Allocations:} For each trade $t$ with $X_t\neq 0$, the system:
\begin{enumerate}[leftmargin=*,topsep=0.25em,itemsep=0.15em]
  \item Generates a fresh allocation identifier $id_t\in ID_s$
  \item Adds $(id_t,t,X_t)$ to the allocation ledger $A_s$
  \item Increments $qty^{alloc}(t)$ by $X_t$
  \item Sets publication status $P_s(id_t)=\mathsf{pending}$
\end{enumerate}

\textbf{Carry Update:} The total allocated quantity is deducted from unallocated carry:
\[
U_s' = U_s - \sum_{t\in Tr_s} X_t.
\]

\textbf{Partial Allocation Behavior:} The operator may allocate zero to some or all trades. If $X_t=0$ for all $t$, then $U_s$ remains unchanged, representing explicit carry forward. This supports partial settlements on either side and across mixed settlement supply sources.

\subsubsection{Exactly-Once Publication to Lending}

Allocations must be communicated to downstream lending systems:
\[
\sigma_s \xrightarrow{\mathsf{PUBLISH}_s(id)}_s \sigma_s'
\qquad
(P_s(id)=\mathsf{pending})
\]

\textbf{Precondition:} The allocation $id$ must be in pending state.

\textbf{Processing (atomic publication):} Within a single atomic transaction, the system:
\begin{enumerate}[leftmargin=*,topsep=0.25em,itemsep=0.15em]
  \item persists the transition that marks the allocation as published,
  \item emits the corresponding allocation message to the downstream lending interface,
  \item and advances the durable input cursor $K_s$ for the consumed $\mathsf{PUBLISH}_s(id)$ trigger record.
\end{enumerate}
Formally, the shard state update is:
\[
P_s'(id)=\mathsf{published}.
\]

\textbf{Downstream Interface Assumption:} The lending system \emph{should} process allocations idempotently by allocation identifier $id$. This makes retries safe in the presence of transient delivery failures outside the transactional boundary.

\subsubsection{End-of-Day Reconciliation}

At end of day, the system reconciles its internal state with CNS obligations and any externally-notified settlement:
\[
\sigma_s \xrightarrow{\mathsf{EOD\_RECON}_s}_s \sigma_s'
\]

\textbf{Discrepancy Calculation:} Compute the signed difference between the \emph{total} PB-side position signal and the system's tracked decomposition:
\[
\epsilon_s \triangleq (O_s + B_s) - (Need_s + U_s).
\]
Here $O_s$ is CNS net open obligation, $B_s$ is cumulative externally-notified settled flow, while $(Need_s + U_s)$ is the system's net open trade demand plus unallocated carry.

\textbf{Processing:} The discrepancy $\epsilon_s$ is recorded externally (e.g., in a break table for investigation). The shard state itself remains unchanged:
\[
\sigma_s' = \sigma_s.
\]

\textbf{Interpretation:} Under normal operation, $\epsilon_s$ should be $0$. A nonzero $\epsilon_s$ indicates a reconciliation break; its sign indicates the direction of the net mismatch.

\subsubsection{Crash and Restart}

The system must survive crashes without losing consistency:

\textbf{Crash Transition:}
\[
\sigma_s \xrightarrow{\mathsf{CRASH}_s}_s \bot_s.
\]
The $\bot_s$ state represents a crashed shard where durable state survives but volatile runtime state is lost.

\textbf{Restart Transition:}
\[
\bot_s \xrightarrow{\mathsf{RESTART}_s}_s \sigma_s'.
\]

\textbf{Recovery Model:} On restart, the shard restores the last \emph{committed} persistent state $(O_s,Tr_s,A_s,U_s,B_s,D_s,P_s,K_s)$.
Processing resumes from the durable message log at position $K_s+1$.
Any in-flight (uncommitted) transition at the time of crash is rolled back (i.e., has no visible effect), and its input record is eligible for reprocessing.

\subsection{Allocation Strategy as an Operator}
\label{sec:alloc-operator}

For a fixed security $s$, define the open-demand vector over shard trades:
\[
open_s(t)\triangleq qty^{open}(t)\ \ (t\in Tr_s),
\qquad
Open_s \in \mathbb{Z}^{Tr_s}.
\]

We model the pluggable allocation strategy as an operator that produces an allocation plan:
\[
\mathcal{F}_{s,\Theta}:\ (Tr_s,\ Open_s,\ U_s)\ \to\ X \in \mathbb{Z}^{Tr_s}.
\]
(Equivalently, $\mathcal{F}_{s,\Theta}$ may be treated as a relation to allow multiple admissible plans.)

\paragraph{Core operator properties.}
For any output plan
$X=\mathcal{F}_{s,\Theta}(Tr_s,Open_s,U_s)$, let $d\triangleq \sgn(U_s)$:
\begin{enumerate}[leftmargin=*]
  \item \khead{Feasibility:}
  if $d=0$ then $X_t=0$ for all $t$; otherwise for all $t\in Tr_s$,
  \[
  \begin{aligned}
  \sgn(open_s(t))\neq d &\Rightarrow X_t=0,
  \qquad \\
  \sgn(open_s(t))=d &\Rightarrow 0 \le d\cdot X_t \le d\cdot open_s(t),
  \end{aligned}
  \]
  and
  \[
  0 \le d\cdot \sum_{t\in Tr_s} X_t \le d\cdot U_s \ (=|U_s|).
  \]
  \item \khead{Eligibility compliance:}
  if $\neg eligible_s(t)$ then $X_t=0$.
  \item \khead{Work-conserving:}
  if $U_s\neq 0$ and $\exists t: eligible_s(t)\wedge \sgn(open_s(t))=\sgn(U_s)$ then $\sum_t X_t\neq 0$.
\end{enumerate}

\subsubsection{Example Client-Fair Allocation Operators (Deterministic and Randomized)}
\label{sec:alloc-examples}

This section gives \emph{examples} of allocation operators $\mathcal{F}_{s,\Theta}$ that are fair \emph{across clients}
rather than across individual trades. These are illustrative and need not match the eventual implementation.

\paragraph{Client-level aggregation.}
For a fixed security $s$ and side $d\triangleq \sgn(U_s)$, define the eligible trade set on the carry side:
\[
Tr_s^{d} \triangleq \{\, t\in Tr_s \mid eligible_s(t)\wedge \sgn(open_s(t))=d \,\}.
\]
Define client-level open demand (signed) on that side:
\[
Open_s^d(c) \triangleq \sum_{t\in Tr_s^{d}:~client(t)=c} open_s(t),
\qquad c\in C.
\]
Note $Open_s^d(c)$ has sign $d$ (or is $0$). Let the eligible client set be
\[
C_s^d \triangleq \{\, c\in C \mid Open_s^d(c)\neq 0 \,\}.
\]
A client-fair operator first chooses a \emph{client allocation} $Y\in \mathbb{Z}^{C_s^d}$ satisfying
\[
\forall c\in C_s^d:\ 0 \le d\cdot Y_c \le d\cdot Open_s^d(c),
\qquad
0 \le d\cdot \sum_{c\in C_s^d} Y_c \le d\cdot U_s,
\]
and then distributes each client’s $Y_c$ across that client’s trades (e.g., FIFO by trade time, or pro-rata).

\paragraph{Within-client distribution (example: FIFO).}
Fix any deterministic total order $\prec$ on trades for the same client (e.g., arrival time, then trade id).
For each client $c$, distribute $Y_c$ over trades
\[
\{t\in Tr_s^d \mid client(t)=c\}
\]
in $\prec$ order, allocating each trade up to its open amount until $Y_c$ is exhausted.
This yields a trade-level plan $X\in \mathbb{Z}^{Tr_s}$.

\begin{remark}[Client fairness scope]
Client fairness means that, under repeated partial settlements, \emph{no client with persistent same-side open demand}
is starved by other clients. This is stronger than trade-level weak fairness when one client has many trades.
\end{remark}

\subsubsection{Example 1: Deterministic Client-Fair Operator (Deficit Round Robin)}
\label{sec:alloc-drr}

\paragraph{Parameters.}
Let $\Theta_s$ include:
(i) a fixed cyclic order $\pi$ of clients (a permutation of $C$),
(ii) a quantum $q\in\mathbb{Z}_{>0}$ (in shares),
and (iii) persistent per-security state variables
a pointer $p_s\in \{1,\dots,|C|\}$ and deficits $def_s:C\to \mathbb{Z}_{\ge 0}$.\footnote{These can be modeled as part of $\Theta_s$ (configuration+strategy state) or split into explicit shard state.}

\paragraph{DRR step (informal).}
Let $cap \triangleq |U_s|$ and work on the side $d=\sgn(U_s)$.
Iterate clients in cyclic order starting at $p_s$.
When visiting client $c$, increase $def_s(c) := def_s(c)+q$.
If $Open_s^d(c)\neq 0$, allocate
\[
a_c \triangleq \min\{\, def_s(c),\ |Open_s^d(c)|,\ cap_{rem}\,\},
\]
set $Y_c := d\cdot a_c$, decrease $def_s(c):=def_s(c)-a_c$ and $cap_{rem}:=cap_{rem}-a_c$.
Continue until $cap_{rem}=0$ or all clients were visited with no further allocation possible.
Finally advance the pointer $p_s$ to the next client after the last visited one.
Then distribute $Y_c$ within client (e.g., FIFO) to obtain $X$.

\paragraph{Why it is fair (intuition).}
If a client $c$ remains eligible (same-side open demand persists), then on each full cycle its deficit grows by $q$,
so eventually $def_s(c)$ becomes large enough to claim allocation whenever supply exists.
Thus no persistently eligible client is starved by other clients.

\subsubsection{Example 2: Randomized Client-Fair Operator (Weighted Lottery with Deterministic Seed)}
\label{sec:alloc-lottery}

\paragraph{Parameters.}
Let $\Theta_s$ include a weight function $w:C\to \mathbb{R}_{>0}$ and a deterministic seed function
\[
seed_s \triangleq H(s, K_s, \text{alloc\_epoch}_s),
\]
where $H$ is a hash and $\text{alloc\_epoch}_s$ is a monotonically increasing counter for $\mathsf{ALLOCATE}_s$ invocations.
(Using a seed makes the randomized choice \emph{replayable} under crash recovery.)

\paragraph{Lottery allocation (client-level).}
Let $cap \triangleq |U_s|$ and $d=\sgn(U_s)$.
Define client weights on the active side:
\[
\omega(c) \triangleq w(c)\cdot |Open_s^d(c)| \quad \text{for } c\in C_s^d.
\]
Repeatedly sample clients with probability proportional to $\omega(c)$ (using PRNG seeded by $seed_s$)
and allocate them one unit at a time (or in chunks), subject to $|Open_s^d(c)|$ and remaining $cap$,
until $cap$ is exhausted or no eligible clients remain.
This produces $Y$ and then (via FIFO or pro-rata within client) a trade-level plan $X$.

\paragraph{Fairness guarantee (in expectation).}
If a client $c$ remains persistently eligible (same-side) and supply events recur,
then in each allocation step it has nonzero probability of receiving units, bounded below by
\[
\Pr[c\ \text{chosen}] \ge \frac{\omega(c)}{\sum_{c'\in C_s^d}\omega(c')}.
\]
Hence the probability that $c$ is starved for infinitely many opportunities is $0$ (under standard independence assumptions),
and its long-run expected allocation share approaches its weight proportion.

\begin{remark}[Deterministic randomness for exactly-once + replay]
Although this operator is \emph{randomized} mathematically, the seeded PRNG makes each $\mathsf{ALLOCATE}_s$
decision a deterministic function of durable inputs and state (e.g., $(s,K_s,\text{alloc\_epoch}_s)$),
preserving reproducibility under crash recovery.
\end{remark}


% ===================== CONCURRENCY =====================
\section{Concurrency Properties Induced by Partitioning}
\label{sec:concurrency}

\begin{proposition}[Cross-Shard Commutativity]
If $key(e_1)\neq key(e_2)$ then the events commute:
\[
(\sigma \xrightarrow{e_1} \sigma_1 \xrightarrow{e_2} \sigma_{12})
\Rightarrow
(\sigma \xrightarrow{e_2} \sigma_2 \xrightarrow{e_1} \sigma_{21})
\wedge
\sigma_{12}=\sigma_{21}.
\]
\end{proposition}

\begin{proof}[Proof sketch]
By definition of the global transition relation, each event updates only its keyed shard and leaves all other shards unchanged.
\end{proof}

% ===================== SAFETY =====================
\section{Safety Properties}
\label{sec:safety}

\begin{proposition}[No Over-Allocation]
For all trades $t$ in any reachable state:
\[
qty^{alloc}(t)\cdot qty^{tot}(t)\ge 0
\quad\wedge\quad
|qty^{alloc}(t)| \le |qty^{tot}(t)|.
\]
\end{proposition}

\begin{proof}[Proof sketch]
Only allocation changes $qty^{alloc}(t)$, and feasibility enforces that allocations have the same sign as open demand and do not exceed it in magnitude, hence cannot exceed $|qty^{tot}(t)|$.
\end{proof}

\begin{proposition}[Allocation Never Exceeds Carry]
In any $\mathsf{ALLOCATE}_s$ transition with pre-state carry $U_s$, the chosen plan $X$ satisfies
\[
\left|\sum_{t\in Tr_s} X_t\right| \le |U_s|
\quad\text{and}\quad
\sgn\!\left(\sum_{t\in Tr_s} X_t\right)\in\{0,\sgn(U_s)\}.
\]
\end{proposition}

\begin{proof}[Proof sketch]
Immediate from the feasibility constraint $0 \le d\cdot \sum_t X_t \le d\cdot U_s$ with $d=\sgn(U_s)$.
\end{proof}

\begin{proposition}[Allocation Conservation Across Multiple Settlement Sources]
For each $s$, carry evolves as:
\[
\begin{aligned}
&U_s := U_s + \Delta settle(s) &&\text{on CNS updates},\\
&U_s := U_s + x &&\text{on }\mathsf{B2B\_SETTLE}_s(eid,x),\\
&U_s := U_s - \sum_t X_t &&\text{on allocations}.
\end{aligned}
\]
Thus total allocated flow cannot exceed the cumulative settled flow contributed by CNS plus externally-notified settlement, on either side.
\end{proposition}

\begin{proof}[Proof sketch]
By construction, $U_s$ is the residual between cumulative settled flow (from both CNS-induced and external sources) and cumulative allocated flow; feasibility prevents allocating more than the current residual magnitude.
\end{proof}

% ===================== EXACTLY ONCE =====================
\section{Exactly-Once Publication and Crash Recovery}
\label{sec:exactly-once}

\begin{proposition}[At-Most-Once Publication in the Model]
For any $id\in ID_s$, $\mathsf{PUBLISH}_s(id)$ transitions the state from $\mathsf{pending}$ to $\mathsf{published}$ and never reverses.
\end{proposition}

\begin{proof}[Proof sketch]
Publishing updates $P_s(id)$ monotonically from pending to published.
\end{proof}

\begin{proposition}[Crash-Safe Publication State]
If $P_s(id)=\mathsf{published}$ before a crash, then after restart $P_s(id)=\mathsf{published}$.
\end{proposition}

\begin{proof}[Proof sketch]
$P_s$ is persistent. By the transactional discipline, once the published state is committed it survives crashes.
\end{proof}

\begin{proposition}[No Lost Allocations Across Crash]
If $(id,t,q)\in A_s$ before a crash, then $(id,t,q)\in A_s$ after restart.
\end{proposition}

\begin{proof}[Proof sketch]
$A_s$ is persistent; committed allocations survive crashes.
\end{proof}

\begin{proposition}[Exactly-Once Downstream Effect]
Under the transactional discipline (atomic state update + downstream publication + cursor advance), each allocation publication has exactly-once downstream effect under retries despite crashes. If the downstream lending system is additionally idempotent on allocation identifier $id$, the guarantee remains robust even if delivery retries occur outside the transaction boundary.
\end{proposition}

\begin{proof}[Proof sketch]
At-most-once: a committed publication advances the cursor and marks $P_s(id)=\mathsf{published}$, so reprocessing the same trigger cannot re-emit a committed publication.
At-least-once: if a crash happens before commit, the cursor does not advance and the trigger is reprocessed after restart, leading to eventual publication.
Downstream idempotence makes any residual duplicate deliveries harmless.
\end{proof}

\begin{proposition}[Exactly-Once Application of External Settlement Notifications]
For any $eid\in EID$, at most one committed transition $\mathsf{B2B\_SETTLE}_s(eid,\cdot)$ is applied to shard state.
\end{proposition}

\begin{proof}[Proof sketch]
The precondition $eid\notin D_s$ and monotone update $D_s := D_s\cup\{eid\}$ ensure the event id cannot be applied twice.
With transactional processing, either the update is committed (and survives crash) or it is rolled back and the input is retried.
\end{proof}

% ===================== FAIRNESS =====================
\section{Fairness for Partial Settlements}
\label{sec:fairness}

\subsection{Eligibility}

Define an eligibility predicate (parameterized by $\Theta_s$):
\[
eligible_s(t) \triangleq (t\in Tr_s)\ \wedge\ (qty^{open}(t)\neq 0)\ \wedge\ \mathsf{ExtraElig}_s(t,\Theta_s).
\]

\subsection{Weak Fairness}

Assume weak fairness per security: if $eligible_s(t)\wedge U_s\neq 0 \wedge \sgn(qty^{open}(t))=\sgn(U_s)$ holds continuously over an infinite suffix, then there exist infinitely many allocation steps where $X_t\neq 0$.

\begin{proposition}[No Starvation Under Persistent Same-Side Supply]
No eligible trade with persistent same-side carry is starved indefinitely.
\end{proposition}

\begin{proof}[Proof sketch]
Immediate from weak fairness.
\end{proof}

% ===================== RECONCILIATION =====================
\section{End-of-Day Reconciliation Convergence}
\label{sec:reconciliation}

\paragraph{Per-Security Reconciliation Equation.}
At end-of-day for each $s$:
\[
(O_s + B_s) = Need_s + U_s + \epsilon_s,
\]
where $\epsilon_s$ is an explicitly recorded signed discrepancy.

\begin{proposition}[Crash-Resilient Convergence Under Stabilization]
Assume: (i) CNS obligations stabilize by EOD, (ii) there exists a time after which no new trades arrive,
(iii) enabled allocation and publish actions are retried indefinitely, (iv) the allocation strategy is weakly fair,
(v) only finitely many crashes occur, and (vi) the external settlement stream is either finite by EOD or stabilizes by EOD.
Then for each security $s$ the system reaches a state with
\[
\epsilon_s=0
\quad\text{and}\quad
(O_s + B_s)=Need_s+U_s.
\]
\end{proposition}

\begin{proof}[Proof sketch]
After stabilization, $O_s$ is constant and no further external settlements arrive, so $U_s$ stops changing due to inputs.
With no new trades, progress comes only from allocation.
While $U_s\neq 0$ and there exist same-side open trades ($\exists t:\ qty^{open}(t)\neq 0 \wedge \sgn(qty^{open}(t))=\sgn(U_s)$),
weak fairness yields allocations that reduce same-side open demand toward $0$ until either same-side demand is exhausted or $U_s$ reaches $0$,
implying $\epsilon_s=0$. Crashes do not erase committed progress because persistent state and the durable cursor restore the shard to its last committed point.
\end{proof}

% ===================== IMPLEMENTATION =====================
\section{Implementation Notes}

Each security $s$ can be implemented as a shard with:
\begin{itemize}[leftmargin=*]
  \item a durable state store for $(O_s,Tr_s,A_s,U_s,B_s,D_s,P_s)$,
  \item a \kfeat{durable ordered message log} providing per-security input streams and a \kfeat{durable cursor} $K_s$,
  \item a \kfeat{transactional processing engine} that commits \emph{atomically}: (i) state updates, (ii) downstream publication (or an outbox/outbound stream append), and (iii) cursor advancement,
  \item a \kfeat{strategy plugin} implementing the operator $\mathcal{F}_{s,\Theta_s}$,
  \item a publisher that retries \kfeat{pending allocations} until \kfeat{published},
  \item an external settlement ingestor that feeds $\mathsf{B2B\_SETTLE}_s(eid,x)$ events and enforces idempotence using $eid$.
\end{itemize}

\end{document}
