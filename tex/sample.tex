\documentclass[sigconf]{acmart}

% ===================== Packages =====================
\usepackage[T1]{fontenc}
\usepackage{mathtools}
\usepackage{microtype}

\usepackage{amsmath,amssymb,amsthm}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{graphicx}   % for \resizebox (fit-to-column helpers)

% Helpers: scale only when needed
\newcommand{\fitcol}[1]{\resizebox{\columnwidth}{!}{$\displaystyle #1$}}
\newcommand{\fitcoltext}[1]{\resizebox{\columnwidth}{!}{$#1$}}

% ===================== Visible "bold" (robust under broken bold fonts) =====================
% If your TeX setup is missing the bold font shapes used by acmart, \textbf/\bfseries can look unchanged.
% These macros force Computer Modern Sans Bold Extended (cmss/bx), which is essentially always available.
\DeclareRobustCommand{\kfeat}[1]{{\fontfamily{cmss}\fontseries{bx}\selectfont #1}}
\DeclareRobustCommand{\khead}[1]{{\fontfamily{cmss}\fontseries{bx}\selectfont #1}}

% ===================== Theorems =====================

% ---- Theorem headings that pop (robust visible-bold, no boxes, no color) ----
\usepackage{amsthm}

\newtheoremstyle{pbplain}
  {6pt}{6pt}{\itshape}{0pt}{} {.}{0.6em}
  {\khead{\thmname{#1}\thmnumber{ #2}}\thmnote{ \khead{(#3)}}}

\newtheoremstyle{pbdef}
  {6pt}{6pt}{\normalfont}{0pt}{} {.}{0.6em}
  {\khead{\thmname{#1}\thmnumber{ #2}}\thmnote{ \khead{(#3)}}}

\theoremstyle{pbdef}
\newtheorem{definition}{Definition}[section]
\newtheorem{remark}{Remark}[section]

\theoremstyle{pbplain}
\newtheorem{proposition}{Proposition}[section]
\newtheorem{corollary}{Corollary}[section]

% ===================== ACM Metadata / Suppression =====================
\settopmatter{printacmref=false}
\setcopyright{none}
\renewcommand\footnotetextcopyrightpermission[1]{}

\acmDOI{}
\acmISBN{}
\acmConference{}{}{}
\acmBooktitle{}
\acmYear{}

% Provide a short title without line breaks for PDF metadata
\title[PB CNS Settlement Allocation System]{Prime Brokerage CNS Settlement Allocation System: Security-ID Partitioning, Exactly-Once Publication, and Crash Recovery}

% Full (typeset) title can still contain line breaks
\title{Prime Brokerage CNS Settlement Allocation System\\
with Security-ID Partitioning, Exactly-Once Publication, and Crash Recovery}

\author{}
\affiliation{%
  \institution{}
  \city{}
  \country{}
}
\date{}

\begin{document}

% ===================== ABSTRACT =====================
\begin{abstract}
This document formally specifies a Prime Brokerage (PB) settlement allocation system as a labeled transition system (LTS).
The system handles Continuous Net Settlement (CNS) obligations by allocating settled securities across client trades.
Key features include: \kfeat{Security-ID partitioning} for parallel processing,
\kfeat{pluggable allocation strategies},
\kfeat{exactly-once publication} guarantees to downstream lending systems,
\kfeat{crash recovery via transactional processing over a durable ordered message log},
and \kfeat{partial-settlement support}.
The formal model enables rigorous reasoning about correctness, fault tolerance, and progress properties.
\end{abstract}

\maketitle

% ===================== INTRODUCTION =====================
\section{Introduction and Overview}

In prime brokerage operations, securities settlement through Continuous Net Settlement (CNS)
systems presents complex challenges. The prime broker acts as a single participant in CNS,
receiving netted obligations for each security. Simultaneously, the PB services numerous
clients whose individual trades must be settled using the securities received through CNS.
This document specifies a system that bridges these two worlds: it allocates CNS-settled
quantities across client trades according to \kfeat{configurable (pluggable) strategies},
handles \kfeat{partial settlements}, ensures \kfeat{exactly-once publication} of allocations to
downstream lending systems, and maintains consistency via \kfeat{crash recovery} even in the face
of failures.

\subsection{Core Challenges and Solutions}

\begin{enumerate}[leftmargin=*]
  \item \khead{Partitioning for Scalability}: Processing is partitioned by \kfeat{security identifier}, allowing independent and parallel processing per security while preserving correctness.
  \item \khead{Exactly-Once Semantics}: Allocations published to lending systems must not be duplicated or lost, even during retries after \kfeat{crashes}.
  \item \khead{Partial Settlement Support}: The system must handle cases where only \kfeat{partial quantities} of securities are available for allocation across client trades.
  \item \khead{Crash Recovery}: The system recovers deterministically using \kfeat{transactional commits} against a \kfeat{durable ordered message log}: state updates, output publication, and advancement of the input cursor occur atomically, so crashes do not lose committed progress.
  \item \khead{End-of-Day Reconciliation}: The system must reconcile allocated quantities with CNS obligations to identify any discrepancies.
\end{enumerate}

\subsection{Modeling Approach}

\begin{enumerate}[leftmargin=*]
  \item Define the global system as a product of per-security shards (Section~\ref{sec:partitioned-lts})
  \item Specify per-shard state and transitions (Section~\ref{sec:per-shard})
  \item Establish correctness invariants and safety properties (Section~\ref{sec:safety})
  \item Prove exactly-once publication and crash recovery guarantees (Section~\ref{sec:exactly-once})
  \item Define fairness and progress properties (Section~\ref{sec:fairness})
  \item Demonstrate end-of-day convergence (Section~\ref{sec:reconciliation})
\end{enumerate}

% ===================== DOMAINS =====================
\section{Domains and Notation}
\label{sec:domains}

\subsection{Sets and Types}

\begin{itemize}[leftmargin=*]
  \item $S$ : finite set of security identifiers (partition keys).
  \item $C$ : finite set of client identifiers.
  \item $T$ : finite set of trade identifiers.
  \item $ID$ : finite set of allocation identifiers.
  \item $\mathbb{Z}$ : integers (positive, negative, and zero).
  \item $\mathbb{Z}_{\ge 0}$ : non-negative integers.
\end{itemize}

\subsection{Trade Representation}

Each trade $t \in T$ represents a client transaction requiring settlement. Trades have immutable attributes recorded at creation:
\[
\begin{aligned}
client(t) &\in C, &&\text{the client who executed the trade}\\
sec(t) &\in S, &&\text{the security being traded}\\
qty^{tot}(t) &\in \mathbb{Z}_{\ge 0}, &&\text{total quantity to be settled (magnitude)}
\end{aligned}
\]

\paragraph{Quantity sign and direction.}
Trade and allocation quantities in this model are \emph{non-negative magnitudes}. Trade direction (e.g., buy vs.\ sell, receive vs.\ deliver) is treated as a separate attribute and is not needed for the allocation mechanics specified here. In contrast, CNS obligations (below) use a \emph{signed} convention: positive means PB is due to receive, negative means PB must deliver.

The system tracks allocated quantity per trade:
\[
qty^{alloc}(t) \in \mathbb{Z}_{\ge 0}, \quad 0 \le qty^{alloc}(t) \le qty^{tot}(t),
\]
and computes open (unallocated) quantity:
\[
qty^{open}(t) \triangleq qty^{tot}(t) - qty^{alloc}(t).
\]

\subsection{CNS Obligations and Settlement Supply}

CNS messages may cover multiple securities, so we model them as partial maps:
\[
M : S \rightharpoonup \mathbb{Z}.
\]

For each security $s \in S$, CNS provides the PB's net open obligation $O(s)\in\mathbb{Z}$.
A positive $O(s)$ indicates CNS owes securities to PB (receive), while negative indicates PB owes CNS (deliver).
The same sign convention applies to each $M(s)$ when present.

The system only allocates settlement supply derived from decreases in receive obligations:
\[
\Delta settle(s) \triangleq \max(0, O_{prev}(s) - O_{new}(s)).
\]

% ===================== PARTITIONED LTS =====================
\section{System as a Partitioned Labeled Transition System}
\label{sec:partitioned-lts}

\subsection{Per-Security Shards}

For each security $s \in S$, define a per-security shard as a labeled transition system:
\[
\mathcal{PB}_s = (\mathcal{S}_s, \mathcal{A}_s, \rightarrow_s, \sigma_{0,s}),
\]
where $\rightarrow_s \subseteq \mathcal{S}_s \times \mathcal{A}_s \times \mathcal{S}_s$.

\subsection{Global System Composition}

The global system is the product of all shards:
\[
\mathcal{PB} =
\left(\prod_{s\in S}\mathcal{S}_s,\ \mathcal{A},\ \rightarrow,\ \prod_{s\in S}\sigma_{0,s}\right).
\]

\subsection{Global Event Routing and Demultiplexing}

Let $\mathcal{E}$ be the set of all incoming events/messages. Each event $e\in\mathcal{E}$ has a security routing key:
\[
key : \mathcal{E} \rightarrow S.
\]

\khead{Routing Rules:}
\begin{itemize}[leftmargin=*]
  \item For trade events $\mathsf{CLIENT\_TRADE}(t)$, $key(\cdot)=sec(t)$.
  \item For publication events $\mathsf{PUBLISH}(id)$, $key(\cdot)=sec(id)$.
  \item For CNS multi-security messages $M:S\rightharpoonup\mathbb{Z}$, ingestion is modeled by demultiplexing into per-security events $\mathsf{MSG}_s(M(s))$ for each $s\in dom(M)$.
\end{itemize}

\khead{Demultiplexing:}
\[
\mathsf{MSG}(M) \equiv \{\, \mathsf{MSG}_s(M(s)) \mid s \in dom(M)\,\}.
\]

\subsection{Global Transition Relation}

Let the global state be $\sigma = \langle \sigma_s \rangle_{s\in S}$. For any event $e$:
\[
\sigma \xrightarrow{e} \sigma'
\ \text{iff}\
\sigma_{key(e)} \xrightarrow{e}_{key(e)} \sigma_{key(e)}'
\ \wedge\
\forall s'\neq key(e):\ \sigma_{s'}'=\sigma_{s'}.
\]

% ===================== PER-SHARD =====================
\section{Per-Shard State, Actions, and Transitions}
\label{sec:per-shard}

\subsection{Per-Shard State Components}

For a fixed security $s\in S$, shard state:
\[
\sigma_s = (O_s,\ Tr_s,\ A_s,\ U_s,\ P_s,\ K_s,\ \Theta_s).
\]

\begin{itemize}[leftmargin=*]
  \item $O_s\in\mathbb{Z}$: current CNS open obligation for security $s$.
  \item $Tr_s\subseteq T$: set of trades with $sec(t)=s$.
  \item $A_s\subseteq ID_s\times T\times\mathbb{Z}_{\ge 0}$: allocation ledger, tuples $(id,t,q)$.
  \item $U_s\in\mathbb{Z}_{\ge 0}$: unallocated settlement carry.
  \item $P_s:ID_s\rightharpoonup\{\mathsf{pending},\mathsf{published}\}$: publication status map.
  \item $K_s\in\mathbb{Z}_{\ge 0}$: durable input cursor (last committed position) for the per-security ordered message stream.
  \item $\Theta_s$: configuration and strategy parameters.
\end{itemize}

\paragraph{Local Identifier Spaces.}
\[
ID = \biguplus_{s\in S} ID_s,
\quad \text{and}\quad
\forall id\in ID_s:\ sec(id)=s.
\]

\subsection{Persistence Model}

All components $(O_s,Tr_s,A_s,U_s,P_s,K_s)$ are persistent and survive crashes. Runtime-only structures are volatile and omitted.

\subsection{Initial State}

\[
\sigma_{0,s} = (0,\ \emptyset,\ \emptyset,\ 0,\ \emptyset,\ 0,\ \Theta_s).
\]

\subsection{Per-Shard Actions}

\begin{equation*}
\mathcal{A}_s \supseteq
\left\{
\vphantom{\sum_{i=1}^{n}}
\begin{aligned}
\mathsf{SOD\_RECON}_s(x),\ &\mathsf{MT570}_s(x),\\
\mathsf{SETTLE\_BATCH}_s(x),\ &\mathsf{CLIENT\_TRADE}_s(t),\\
\mathsf{ALLOCATE}_s,\ &\mathsf{PUBLISH}_s(id),\\
\mathsf{EOD\_RECON}_s,\ &\mathsf{CRASH}_s,\\
\mathsf{RESTART}_s &
\end{aligned}
\right\}
\end{equation*}

where $x\in\mathbb{Z}$, $t\in T$ with $sec(t)=s$, and $id\in ID_s$.

\subsection{Transactional Processing Discipline (Normative)}

\khead{Atomicity assumption (exactly-once engine):}
For any input-driven action (e.g., $\mathsf{MT570}_s(\cdot)$, $\mathsf{CLIENT\_TRADE}_s(\cdot)$, $\mathsf{PUBLISH}_s(\cdot)$), the implementation executes a single atomic transaction that:
\begin{enumerate}[leftmargin=*,topsep=0.25em,itemsep=0.15em]
  \item persists the resulting shard state updates (e.g., $A_s,U_s,P_s,O_s,Tr_s$),
  \item emits the corresponding output message to the downstream lending interface when applicable (notably for $\mathsf{PUBLISH}_s(id)$),
  \item and advances the durable input cursor $K_s$ to acknowledge the consumed input record.
\end{enumerate}
If a crash occurs before commit, \emph{none} of these effects become visible; on restart, the system resumes from the last committed $K_s$ and reprocesses remaining input records. This is the sole crash-recovery mechanism required by the design (no separate per-shard WAL is assumed).

\subsection{Derived Quantities}

\[
Need_s \triangleq \sum_{t \in Tr_s} qty^{open}(t).
\]
This $Need_s$ represents the total settlement demand from all client trades for security $s$. It guides allocation decisions and appears in the end-of-day reconciliation equation.

% ===================== TRANSITIONS =====================
\subsection{Per-Shard Transition Relation: Detailed Explanations}

The following transitions define the core operational behavior of each security shard. Input-driven transitions are committed transactionally together with cursor advancement as specified above; internal transitions (e.g., $\mathsf{ALLOCATE}_s$) may also be executed transactionally, but do not necessarily advance $K_s$.

\subsubsection{Start-of-Day Reconciliation}

The system reconciles with CNS at start of day to establish the initial obligation position:
\[
\sigma_s \xrightarrow{\mathsf{SOD\_RECON}_s(x)}_s \sigma_s'
\]

\textbf{Processing:} Update the new CNS obligation $x$ for security $s$:
\[
O_s' = x.
\]

\textbf{Purpose:} This establishes the baseline for tracking settlement supply. If $x>0$, it represents an initial receive obligation from CNS; if $x\leq 0$, no initial settlement supply exists.

\subsubsection{CNS Updates (MT570, Settle Batch)}

CNS provides updates through MT570 messages or settle batch notifications. These transitions handle changes to CNS obligations:
\[
\sigma_s \xrightarrow{\mathsf{MT570}_s(x)}_s \sigma_s'
\quad\text{or}\quad
\sigma_s \xrightarrow{\mathsf{SETTLE\_BATCH}_s(x)}_s \sigma_s'.
\]

\textbf{Processing:} First compute the settlement supply $\delta$, which captures any decrease in receive obligations:
\[
\delta \triangleq \max(0,\ O_s - x).
\]
Then update carry and obligation:
\[
U_s' = U_s + \delta,
\qquad
O_s' = x.
\]

\textbf{Business Logic:} Only decreases in positive obligations yield settlement supply. Increases in obligations (or movements from deliver to receive) do not create supply. This matches the physical reality: the PB can only allocate securities it has actually received from CNS.

\subsubsection{Client Trade Arrival}

New client trades arrive continuously throughout the day:
\[
\sigma_s \xrightarrow{\mathsf{CLIENT\_TRADE}_s(t)}_s \sigma_s'
\qquad
(sec(t)=s)
\]

\textbf{Precondition:} The trade $t$ must be for security $s$, i.e., $sec(t)=s$.

\textbf{Processing:} Add the trade to the trade set:
\[
Tr_s' = Tr_s \cup \{t\}.
\]

\textbf{Note:} The trade's total quantity $qty^{tot}(t)$ is immutable and recorded when the trade is added. Initially, $qty^{alloc}(t)=0$ and $qty^{open}(t)=qty^{tot}(t)$.

\subsubsection{Allocation (Pluggable, Partial)}

This is the core transition where settlement supply is allocated to client trades:
\[
\sigma_s \xrightarrow{\mathsf{ALLOCATE}_s}_s \sigma_s'
\]

\textbf{Strategy Invocation:} The system invokes the pluggable allocation strategy:
\[
\mathsf{Strategy}_s : (Tr_s,\ U_s,\ \Theta_s) \rightarrow \{X_t\}_{t\in Tr_s}
\]
where each $X_t \in \mathbb{Z}_{\ge 0}$ represents the quantity to allocate to trade $t$.

\textbf{Feasibility Constraints:} The strategy must respect:
\[
\forall t\in Tr_s:\ 0 \le X_t \le qty^{open}(t),
\qquad
\sum_{t\in Tr_s} X_t \le U_s.
\]
The first constraint prevents over-allocation to individual trades; the second ensures the allocation doesn't exceed available supply.

\textbf{Processing for Positive Allocations:} For each trade $t$ with $X_t>0$, the system:
\begin{enumerate}[leftmargin=*,topsep=0.25em,itemsep=0.15em]
  \item Generates a fresh allocation identifier $id_t\in ID_s$
  \item Adds $(id_t,t,X_t)$ to the allocation ledger $A_s$
  \item Increments $qty^{alloc}(t)$ by $X_t$
  \item Sets publication status $P_s(id_t)=\mathsf{pending}$
\end{enumerate}

\textbf{Supply Reduction:} The total allocated quantity is deducted from unallocated carry:
\[
U_s' = U_s - \sum_{t\in Tr_s} X_t.
\]

\textbf{Partial Allocation Behavior:} The strategy may allocate zero to some or all trades. If $X_t=0$ for all $t$, then $U_s$ remains unchanged, representing explicit carry forward. This allows the system to handle partial settlements: when insufficient supply exists to satisfy all demand, the strategy determines which trades get allocation and in what amounts.

\subsubsection{Exactly-Once Publication to Lending}

Allocations must be communicated to downstream lending systems:
\[
\sigma_s \xrightarrow{\mathsf{PUBLISH}_s(id)}_s \sigma_s'
\qquad
(P_s(id)=\mathsf{pending})
\]

\textbf{Precondition:} The allocation $id$ must be in pending state.

\textbf{Processing (atomic publication):} Within a single atomic transaction, the system:
\begin{enumerate}[leftmargin=*,topsep=0.25em,itemsep=0.15em]
  \item persists the transition that marks the allocation as published,
  \item emits the corresponding allocation message to the downstream lending interface,
  \item and advances the durable input cursor $K_s$ for the consumed $\mathsf{PUBLISH}_s(id)$ trigger record.
\end{enumerate}
Formally, the shard state update is:
\[
P_s'(id)=\mathsf{published}.
\]

\textbf{Downstream Interface Assumption (recommended):} The lending system \emph{should} process allocations idempotently by allocation identifier $id$. This makes retries safe in the presence of transient delivery failures outside the transactional boundary.

\subsubsection{End-of-Day Reconciliation}

At end of day, the system reconciles its internal state with CNS obligations:
\[
\sigma_s \xrightarrow{\mathsf{EOD\_RECON}_s}_s \sigma_s'
\]

\textbf{Discrepancy Calculation:} Compute the difference between what CNS says should be available and what the system tracks:
\[
\epsilon_s \triangleq \max(0,O_s) - (Need_s + U_s).
\]
Here $\max(0,O_s)$ represents securities CNS indicates are available (only positive obligations count). The term $(Need_s + U_s)$ represents what the system tracks: open trade demand plus unallocated carry.

\textbf{Processing:} The discrepancy $\epsilon_s$ is recorded externally (e.g., in a break table for investigation). The shard state itself remains unchanged:
\[
\sigma_s' = \sigma_s.
\]

\textbf{Interpretation:} A positive $\epsilon_s$ suggests the system has allocated less than what CNS indicates is available (potential under-allocation). A negative $\epsilon_s$ suggests the system has allocated more than available (impossible under our invariants). Under normal operation, $\epsilon_s$ should be zero.

\subsubsection{Crash and Restart}

The system must survive crashes without losing consistency:

\textbf{Crash Transition:}
\[
\sigma_s \xrightarrow{\mathsf{CRASH}_s}_s \bot_s.
\]
The $\bot_s$ state represents a crashed shard where durable state survives but volatile runtime state is lost.

\textbf{Restart Transition:}
\[
\bot_s \xrightarrow{\mathsf{RESTART}_s}_s \sigma_s'.
\]

\textbf{Recovery Model:} On restart, the shard restores the last \emph{committed} persistent state $(O_s,Tr_s,A_s,U_s,P_s,K_s)$. Processing resumes from the durable message log at position $K_s+1$. Any in-flight (uncommitted) transition at the time of crash is rolled back (i.e., has no visible effect), and its input record is eligible for reprocessing.

\subsection{Allocation Strategy as an Operator}
\label{sec:alloc-operator}

For a fixed security $s$, define the open-demand vector over shard trades:
\[
open_s(t)\triangleq qty^{open}(t)\ \ (t\in Tr_s),
\qquad
Open_s \in \mathbb{Z}_{\ge 0}^{Tr_s}.
\]

We model the pluggable allocation strategy as an operator that produces an allocation plan:
\[
\mathcal{F}_{s,\Theta}:\ (Tr_s,\ Open_s,\ U_s)\ \to\ X \in \mathbb{Z}_{\ge 0}^{Tr_s}.
\]
(Equivalently, $\mathcal{F}_{s,\Theta}$ may be treated as a relation to allow multiple admissible plans.)

\paragraph{Core operator properties.}
For any output plan $X=\mathcal{F}_{s,\Theta}(Tr_s,Open_s,U_s)$:
\begin{enumerate}[leftmargin=*]
  \item \khead{Feasibility:}
  $\forall t\in Tr_s:\ 0\le X_t \le open_s(t)$ and $\sum_{t\in Tr_s} X_t \le U_s$.
  \item \khead{Eligibility compliance (if applicable):}
  if $\neg eligible_s(t)$ then $X_t=0$.
  \item \khead{Work-conserving (recommended):}
  if $U_s>0$ and $\exists t: eligible_s(t)\wedge open_s(t)>0$ then $\sum_t X_t>0$.
  \item \khead{Commit-stability (recommended):}
  the plan depends only on committed shard state and $\Theta_s$; any nondeterminism is seeded from persisted data.
\end{enumerate}


% ===================== CONCURRENCY =====================
\section{Concurrency Properties Induced by Partitioning}
\label{sec:concurrency}

\begin{proposition}[Cross-Shard Commutativity]
If $key(e_1)\neq key(e_2)$ then the events commute:
\[
(\sigma \xrightarrow{e_1} \sigma_1 \xrightarrow{e_2} \sigma_{12})
\Rightarrow
(\sigma \xrightarrow{e_2} \sigma_2 \xrightarrow{e_1} \sigma_{21})
\wedge
\sigma_{12}=\sigma_{21}.
\]
\end{proposition}

\begin{proof}[Proof sketch]
By definition of the global transition relation, each event updates only its keyed shard and leaves all other shards unchanged.
\end{proof}

% ===================== SAFETY =====================
\section{Safety Properties}
\label{sec:safety}

\begin{proposition}[No Over-Allocation]
For all trades $t$ in any reachable state:
\[
0 \le qty^{alloc}(t) \le qty^{tot}(t).
\]
\end{proposition}

\begin{proof}[Proof sketch]
Only allocation increases $qty^{alloc}(t)$, and feasibility enforces $X_t \le qty^{open}(t)$.
\end{proof}

\begin{proposition}[Non-Negative Carry]
For all securities $s$ in any reachable state:
\[
U_s \ge 0.
\]
\end{proposition}

\begin{proof}[Proof sketch]
$U_s$ increases only by $\delta\ge 0$ and decreases only by at most its current value.
\end{proof}

\begin{proposition}[Allocation Conservation]
For each $s$, allocations are bounded by cumulative settlement supply implied by CNS decreases (i.e., carry increments).
\end{proposition}

\begin{proof}[Proof sketch]
All allocations draw only from $U_s$, and $U_s$ increases only via obligation decreases.
\end{proof}

% ===================== EXACTLY ONCE =====================
\section{Exactly-Once Publication and Crash Recovery}
\label{sec:exactly-once}

\begin{proposition}[At-Most-Once Publication in the Model]
For any $id\in ID_s$, $\mathsf{PUBLISH}_s(id)$ transitions the state from $\mathsf{pending}$ to $\mathsf{published}$ and never reverses.
\end{proposition}

\begin{proof}[Proof sketch]
Publishing updates $P_s(id)$ monotonically from pending to published.
\end{proof}

\begin{proposition}[Crash-Safe Publication State]
If $P_s(id)=\mathsf{published}$ before a crash, then after restart $P_s(id)=\mathsf{published}$.
\end{proposition}

\begin{proof}[Proof sketch]
$P_s$ is persistent. By the transactional discipline, once the published state is committed it survives crashes.
\end{proof}

\begin{proposition}[No Lost Allocations Across Crash]
\hfill\break
If $(id,t,q)\in A_s$ before a crash, then $(id,t,q)\in A_s$ after restart.
\end{proposition}

\begin{proof}[Proof sketch]
$A_s$ is persistent; committed allocations survive crashes.
\end{proof}

\begin{proposition}[Exactly-Once Downstream Effect]
Under the transactional discipline (atomic state update + downstream publication + cursor advance), each allocation publication has exactly-once downstream effect under retries despite crashes. If the downstream lending system is additionally idempotent on allocation identifier $id$, the guarantee remains robust even if delivery retries occur outside the transaction boundary.
\end{proposition}

\begin{proof}[Proof sketch]
At-most-once: a committed publication advances the cursor and marks $P_s(id)=\mathsf{published}$, so reprocessing the same trigger cannot re-emit a committed publication.
At-least-once: if a crash happens before commit, the cursor does not advance and the trigger is reprocessed after restart, leading to eventual publication.
Downstream idempotence makes any residual duplicate deliveries harmless.
\end{proof}

% ===================== FAIRNESS =====================
\section{Fairness for Partial Settlements}
\label{sec:fairness}

\subsection{Eligibility}

Define an eligibility predicate (parameterized by $\Theta_s$):
\[
eligible_s(t) \triangleq (t\in Tr_s)\ \wedge\ (qty^{open}(t)>0)\ \wedge\ \mathsf{ExtraElig}_s(t,\Theta_s).
\]

\subsection{Weak Fairness}

Assume weak fairness per security: if $eligible_s(t)\wedge U_s>0$ holds continuously over an infinite suffix, then there exist infinitely many allocation steps where $X_t>0$.

\begin{proposition}[No Starvation Under Persistent Supply]
No eligible trade with persistent supply is starved indefinitely.
\end{proposition}

\begin{proof}[Proof sketch]
Immediate from weak fairness.
\end{proof}

% ===================== RECONCILIATION =====================
\section{End-of-Day Reconciliation Convergence}
\label{sec:reconciliation}

\paragraph{Per-Security Reconciliation Equation.}
At end-of-day for each $s$:
\[
\max(0,O_s) = Need_s + U_s + \epsilon_s,
\]
where $\epsilon_s$ is an explicitly recorded discrepancy.

\begin{proposition}[Crash-Resilient Convergence Under Stabilization]
Assume: (i) CNS obligations stabilize by EOD, (ii) there exists a time after which no new trades arrive,
(iii) enabled allocation and publish actions are retried indefinitely, (iv) the allocation strategy is weakly fair,
and (v) only finitely many crashes occur. Then for each security $s$ the system reaches a state with
\[
\epsilon_s=0
\quad\text{and}\quad
\max(0,O_s)=Need_s+U_s.
\]
\end{proposition}

\begin{proof}[Proof sketch]
After stabilization, $O_s$ is constant so $U_s$ stops increasing. With no new trades, progress comes only from allocation.
While $U_s>0$ and $Need_s>0$, weak fairness yields allocations that reduce $Need_s$ until either $Need_s=0$ or $U_s=0$,
implying $\epsilon_s=0$. Crashes do not erase committed progress because persistent state and the durable cursor restore the shard to its last committed point.
\end{proof}

% ===================== IMPLEMENTATION =====================
\section{Implementation Notes (Non-Normative)}

Each security $s$ can be implemented as a shard with:
\begin{itemize}[leftmargin=*]
  \item a durable state store for $(O_s,Tr_s,A_s,U_s,P_s)$,
  \item a \kfeat{durable ordered message log} providing per-security input streams and a \kfeat{durable cursor} $K_s$,
  \item a \kfeat{transactional processing engine} that commits \emph{atomically}: (i) state updates, (ii) downstream publication (or an outbox/outbound stream append), and (iii) cursor advancement,
  \item a \kfeat{strategy plugin} implementing $\mathsf{Strategy}_s$,
  \item a publisher that retries \kfeat{pending allocations} until \kfeat{published}.
\end{itemize}

\end{document}
