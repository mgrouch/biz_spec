\documentclass[sigconf]{acmart}

% ===================== Packages =====================
\usepackage[T1]{fontenc}
\usepackage{mathtools}
\usepackage{microtype}

\usepackage{amsmath,amssymb,amsthm}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{graphicx}   % for \resizebox (fit-to-column helpers)

% Helpers: scale only when needed
\newcommand{\fitcol}[1]{\resizebox{\columnwidth}{!}{$\displaystyle #1$}}
\newcommand{\fitcoltext}[1]{\resizebox{\columnwidth}{!}{$#1$}}

% ===================== Visible "bold" (robust under broken bold fonts) =====================
% If your TeX setup is missing the bold font shapes used by acmart, \textbf/\bfseries can look unchanged.
% These macros force Computer Modern Sans Bold Extended (cmss/bx), which is essentially always available.
\DeclareRobustCommand{\kfeat}[1]{{\fontfamily{cmss}\fontseries{bx}\selectfont #1}}
\DeclareRobustCommand{\khead}[1]{{\fontfamily{cmss}\fontseries{bx}\selectfont #1}}

% ===================== Theorems =====================
\usepackage{amsthm}

\newtheoremstyle{pbplain}
  {6pt}{6pt}{\itshape}{0pt}{} {.}{0.6em}
  {\khead{\thmname{#1}\thmnumber{ #2}}\thmnote{ \khead{(#3)}}}

\newtheoremstyle{pbdef}
  {6pt}{6pt}{\normalfont}{0pt}{} {.}{0.6em}
  {\khead{\thmname{#1}\thmnumber{ #2}}\thmnote{ \khead{(#3)}}}

\theoremstyle{pbdef}
\newtheorem{definition}{Definition}[section]
\newtheorem{remark}{Remark}[section]

\theoremstyle{pbplain}
\newtheorem{proposition}{Proposition}[section]
\newtheorem{corollary}{Corollary}[section]

% ===================== Operators =====================
\DeclareMathOperator{\sgn}{sgn}

% ===================== ACM Metadata / Suppression =====================
\settopmatter{printacmref=false}
\setcopyright{none}
\renewcommand\footnotetextcopyrightpermission[1]{}

\acmDOI{}
\acmISBN{}
\acmConference{}{}{}
\acmBooktitle{}
\acmYear{}

% Provide a short title without line breaks for PDF metadata
\title[PB CNS Settlement Allocation System]{Prime Brokerage CNS Settlement Allocation System: Security-ID Partitioning, Exactly-Once Publication, and Crash Recovery}

% Full (typeset) title can still contain line breaks
\title{Prime Brokerage CNS Settlement Allocation System\\
with Security-ID Partitioning, Exactly-Once Publication, and Crash Recovery}

\author{}
\affiliation{%
  \institution{}
  \city{}
  \country{}
}
\date{}

\begin{document}

% ===================== ABSTRACT =====================
\begin{abstract}
This document formally specifies a Prime Brokerage (PB) settlement allocation system as a labeled transition system (LTS).
The system handles Continuous Net Settlement (CNS) obligations by allocating settled securities flows across client trades,
covering both receive- and deliver-side settlement using a signed-quantity convention.
Key features include: \kfeat{Security-ID partitioning} for parallel processing,
\kfeat{pluggable allocation strategies},
\kfeat{exactly-once publication} guarantees to downstream lending systems,
\kfeat{crash recovery via transactional processing over a durable ordered message log},
and \kfeat{partial-settlement support}.
The formal model enables rigorous reasoning about correctness, fault tolerance, and progress properties.
\end{abstract}

\maketitle
\pagestyle{plain}

% ===================== INTRODUCTION =====================
\section{Introduction and Overview}

In prime brokerage operations, securities settlement through Continuous Net Settlement (CNS)
systems presents complex challenges. The prime broker acts as a single participant in CNS,
receiving netted obligations for each security. Simultaneously, the PB services numerous
clients whose individual trades must be settled using the securities received from or delivered into CNS.
This document specifies a system that bridges these two worlds: it allocates CNS-settled
quantities across client trades according to \kfeat{configurable (pluggable) strategies},
handles \kfeat{partial settlements}, ensures \kfeat{exactly-once publication} of allocations to
downstream lending systems, and maintains consistency via \kfeat{crash recovery} even in the face
of failures.

\subsection{Core Challenges and Solutions}

\begin{enumerate}[leftmargin=*]
  \item \khead{Partitioning for Scalability}: Processing is partitioned by \kfeat{security identifier}, allowing independent and parallel processing per security while preserving correctness.
  \item \khead{Exactly-Once Semantics}: Allocations published to lending systems must not be duplicated or lost, even during retries after \kfeat{crashes}.
  \item \khead{Partial Settlement Support}: The system must handle cases where only \kfeat{partial quantities} of securities are available for allocation across client trades.
  \item \khead{Crash Recovery}: The system recovers deterministically using \kfeat{transactional commits} against a \kfeat{durable ordered message log}: state updates, output publication, and advancement of the input cursor occur atomically, so crashes do not lose committed progress.
  \item \khead{End-of-Day Reconciliation}: The system must reconcile allocated quantities with CNS obligations to identify any discrepancies.
\end{enumerate}

\subsection{Modeling Approach}

\begin{enumerate}[leftmargin=*]
  \item Define the global system as a product of per-security shards (Section~\ref{sec:partitioned-lts})
  \item Specify per-shard state and transitions (Section~\ref{sec:per-shard})
  \item Establish correctness invariants and safety properties (Section~\ref{sec:safety})
  \item Prove exactly-once publication and crash recovery guarantees (Section~\ref{sec:exactly-once})
  \item Define fairness and progress properties (Section~\ref{sec:fairness})
  \item Demonstrate end-of-day convergence (Section~\ref{sec:reconciliation})
\end{enumerate}

% ===================== DOMAINS =====================
\section{Domains and Notation}
\label{sec:domains}

\subsection{Sets and Types}

\begin{itemize}[leftmargin=*]
  \item $S$ : finite set of security identifiers (partition keys).
  \item $C$ : finite set of client identifiers.
  \item $T$ : finite set of trade identifiers.
  \item $ID$ : finite set of allocation identifiers.
  \item $\mathbb{Z}$ : integers (positive, negative, and zero).
  \item $\mathbb{Z}_{\ge 0}$ : non-negative integers.
\end{itemize}

\subsection{Trade Representation}

Each trade $t \in T$ represents a client transaction requiring settlement. Trades have immutable attributes recorded at creation:
\[
\begin{aligned}
client(t) &\in C, &&\text{the client who executed the trade}\\
sec(t) &\in S, &&\text{the security being traded}\\
qty^{tot}(t) &\in \mathbb{Z}, &&\text{total quantity to be settled}
\end{aligned}
\]
\hfill\break 
(signed: $>0$ receive, $<0$ deliver)

\paragraph{Quantity sign and direction.}
Trade and allocation quantities in this model use a \emph{signed} convention:
$qty^{tot}(t)>0$ denotes a receive trade (PB is due to receive securities),
and $qty^{tot}(t)<0$ denotes a deliver trade (PB is due to deliver securities).
CNS obligations (below) use the same signed convention.

The system tracks allocated quantity per trade:
\[
\begin{aligned}
qty^{alloc}(t) &\in \mathbb{Z},
\qquad
qty^{alloc}(t)\cdot qty^{tot}(t)\ge 0,
\qquad \\
|qty^{alloc}(t)| &\le |qty^{tot}(t)|.
\end{aligned}
\]
Open (unallocated) quantity is:
\[
qty^{open}(t) \triangleq qty^{tot}(t) - qty^{alloc}(t).
\]
Thus $qty^{open}(t)$ has the same sign as $qty^{tot}(t)$ (or is $0$), and decreases toward $0$ as settlement is allocated.

\subsection{CNS Obligations and Settlement Supply}

CNS messages may cover multiple securities, so we model them as partial maps:
\[
M : S \rightharpoonup \mathbb{Z}.
\]

For each security $s \in S$, CNS provides the PB's net open obligation $O(s)\in\mathbb{Z}$.
A positive $O(s)$ indicates CNS owes securities to PB (receive), while negative indicates PB owes CNS (deliver).
The same sign convention applies to each $M(s)$ when present.

\paragraph{Settlement flow induced by obligation changes.}
The allocatable settled flow for security $s$ induced by an obligation update is:
\[
\Delta settle(s) \triangleq
\begin{cases}
O_{prev}(s) - O_{new}(s),
& \text{if } \sgn(O_{prev}(s))=\sgn(O_{new}(s))\ \wedge\ |O_{new}(s)|<|O_{prev}(s)|,\\
O_{prev}(s),
& \text{if } \sgn(O_{prev}(s))\neq \sgn(O_{new}(s)),\\
0, & \text{otherwise.}
\end{cases}
\]
A positive $\Delta settle(s)$ means PB \emph{received} securities; a negative value means PB \emph{delivered} securities.

% ===================== PARTITIONED LTS =====================
\section{System as a Partitioned Labeled Transition System}
\label{sec:partitioned-lts}

\subsection{Per-Security Shards}

For each security $s \in S$, define a per-security shard as a labeled transition system:
\[
\mathcal{PB}_s = (\mathcal{S}_s, \mathcal{A}_s, \rightarrow_s, \sigma_{0,s}),
\]
where $\rightarrow_s \subseteq \mathcal{S}_s \times \mathcal{A}_s \times \mathcal{S}_s$.

\subsection{Global System Composition}

The global system is the product of all shards:
\[
\mathcal{PB} =
\left(\prod_{s\in S}\mathcal{S}_s,\ \mathcal{A},\ \rightarrow,\ \prod_{s\in S}\sigma_{0,s}\right).
\]

\subsection{Global Event Routing and Demultiplexing}

Let $\mathcal{E}$ be the set of all incoming events/messages. Each event $e\in\mathcal{E}$ has a security routing key:
\[
key : \mathcal{E} \rightarrow S.
\]

\khead{Routing Rules:}
\begin{itemize}[leftmargin=*]
  \item For trade events $\mathsf{CLIENT\_TRADE}(t)$, $key(\cdot)=sec(t)$.
  \item For publication events $\mathsf{PUBLISH}(id)$, $key(\cdot)=sec(id)$.
  \item For CNS multi-security messages $M:S\rightharpoonup\mathbb{Z}$, ingestion is modeled by demultiplexing into per-security events
\hfill\break
  $\mathsf{MSG}_s(M(s))$ for each $s\in dom(M)$.
\end{itemize}

\khead{Demultiplexing:}
\[
\mathsf{MSG}(M) \equiv \{\, \mathsf{MSG}_s(M(s)) \mid s \in dom(M)\,\}.
\]

\subsection{Global Transition Relation}

Let the global state be $\sigma = \langle \sigma_s \rangle_{s\in S}$. For any event $e$:
\[
\sigma \xrightarrow{e} \sigma'
\ \text{iff}\
\sigma_{key(e)} \xrightarrow{e}_{key(e)} \sigma_{key(e)}'
\ \wedge\
\forall s'\neq key(e):\ \sigma_{s'}'=\sigma_{s'}.
\]

% ===================== PER-SHARD =====================
\section{Per-Shard State, Actions, and Transitions}
\label{sec:per-shard}

\subsection{Per-Shard State Components}

For a fixed security $s\in S$, shard state:
\[
\sigma_s = (O_s,\ Tr_s,\ A_s,\ U_s,\ P_s,\ K_s,\ \Theta_s).
\]

\begin{itemize}[leftmargin=*]
  \item $O_s\in\mathbb{Z}$: current CNS open obligation for security $s$.
  \item $Tr_s\subseteq T$: set of trades with $sec(t)=s$.
  \item $A_s\subseteq ID_s\times T\times\mathbb{Z}$: allocation ledger, tuples $(id,t,q)$ (signed $q$).
  \item $U_s\in\mathbb{Z}$: unallocated settled-flow carry (signed).
  \item $P_s:ID_s\rightharpoonup\{\mathsf{pending},\mathsf{published}\}$: publication status map.
  \item $K_s\in\mathbb{Z}_{\ge 0}$: durable input cursor (last committed position) for the per-security ordered message stream.
  \item $\Theta_s$: configuration and strategy parameters.
\end{itemize}

\begin{proposition}[Cursor Monotonicity]
For all reachable states, $K_s$ is non-decreasing and increases with each commit of input-driven transitions.
\end{proposition}

\paragraph{Local Identifier Spaces.}
\[
ID = \biguplus_{s\in S} ID_s,
\quad \text{and}\quad
\forall id\in ID_s:\ sec(id)=s.
\]

\subsection{Persistence Model}

All components $(O_s,Tr_s,A_s,U_s,P_s,K_s)$ are persistent and survive crashes. Runtime-only structures are volatile and omitted.

\subsection{Initial State}

\[
\sigma_{0,s} = (0,\ \emptyset,\ \emptyset,\ 0,\ \emptyset,\ 0,\ \Theta_s).
\]

\subsection{Per-Shard Actions}

\begin{equation*}
\mathcal{A}_s \supseteq
\left\{
\vphantom{\sum_{i=1}^{n}}
\begin{aligned}
\mathsf{SOD\_RECON}_s(x),\ &\mathsf{MT570}_s(x),\\
\mathsf{SETTLE\_BATCH}_s(x),\ &\mathsf{CLIENT\_TRADE}_s(t),\\
\mathsf{ALLOCATE}_s,\ &\mathsf{PUBLISH}_s(id),\\
\mathsf{EOD\_RECON}_s,\ &\mathsf{CRASH}_s,\\
\mathsf{RESTART}_s &
\end{aligned}
\right\}
\end{equation*}

where $x\in\mathbb{Z}$, $t\in T$ with $sec(t)=s$, and $id\in ID_s$.

\subsection{Transactional Processing Discipline (Normative)}

\khead{Atomicity assumption (exactly-once engine):}
For any input-driven action ($\mathsf{MT570}_s(\cdot)$, $\mathsf{CLIENT\_TRADE}_s(\cdot)$, $\mathsf{PUBLISH}_s(\cdot)$), the implementation executes a single atomic transaction that:
\begin{enumerate}[leftmargin=*,topsep=0.25em,itemsep=0.15em]
  \item persists the resulting shard state updates ($A_s,U_s,P_s,O_s,Tr_s$),
  \item emits the corresponding output message(s) to the downstream lending interface when applicable
        (notably for $\mathsf{CLIENT\_TRADE}_s(t)$ and $\mathsf{PUBLISH}_s(id)$),
  \item and advances the durable input cursor $K_s$ to acknowledge the consumed input record.
\end{enumerate}
If a crash occurs before commit, \emph{none} of these effects become visible; on restart, the system resumes from the last committed $K_s$ and reprocesses remaining input records. This is the sole crash-recovery mechanism required by the design (no separate per-shard WAL is assumed).

\subsection{Derived Quantities}

\[
Need_s \triangleq \sum_{t \in Tr_s} qty^{open}(t).
\]
This $Need_s$ represents the \emph{net} open settlement demand from all client trades for security $s$ (signed: 
\hfill\break
receive positive, deliver negative). It guides allocation decisions and appears in the end-of-day reconciliation equation.

% ===================== TRANSITIONS =====================
\subsection{Per-Shard Transition Relation: Detailed Explanations}

The following transitions define the core operational behavior of each security shard. Input-driven transitions are committed transactionally together with cursor advancement as specified above; internal transitions (e.g., $\mathsf{ALLOCATE}_s$) may also be executed transactionally, but do not necessarily advance $K_s$.

\subsubsection{Start-of-Day Reconciliation}

The system reconciles with CNS at start of day to establish the initial obligation position:
\[
\sigma_s \xrightarrow{\mathsf{SOD\_RECON}_s(x)}_s \sigma_s'
\]

\textbf{Processing:} Update the new CNS obligation $x$ for security $s$:
\[
O_s' = x.
\]

\textbf{Purpose:} This establishes the baseline for tracking settlement flow on either side (receive if $x>0$, deliver if $x<0$).

\subsubsection{CNS Updates (MT570, Settle Batch)}

CNS provides updates through MT570 messages or settle batch notifications. These transitions handle changes to CNS obligations:
\[
\sigma_s \xrightarrow{\mathsf{MT570}_s(x)}_s \sigma_s'
\quad\text{or}\quad
\sigma_s \xrightarrow{\mathsf{SETTLE\_BATCH}_s(x)}_s \sigma_s'.
\]

\textbf{Processing:} Compute allocatable settled flow induced by the obligation change:
\[
\delta \triangleq \Delta settle(s)\ \text{with } O_{prev}(s)=O_s,\ O_{new}(s)=x.
\]
Then update carry and obligation:
\[
U_s' = U_s + \delta,
\qquad
O_s' = x.
\]

\textbf{Business Logic:} Allocatable settled flow is created only when $|O_s|$ decreases (or the sign flips, settling the prior side).
Pure increases in $|O_s|$ represent new/expanded obligations and do not create allocatable settled flow.

\subsubsection{Client Trade Arrival}

New client trades arrive continuously throughout the day:
\[
\sigma_s \xrightarrow{\mathsf{CLIENT\_TRADE}_s(t)}_s \sigma_s'
\qquad
(sec(t)=s)
\]

\textbf{Precondition:} The trade $t$ must be for security $s$, i.e., $sec(t)=s$.

\textbf{Processing:} Within a single atomic transaction, the system:
\begin{enumerate}[leftmargin=*,topsep=0.25em,itemsep=0.15em]
  \item adds the trade to the shard trade set,
  \item emits a corresponding \emph{trade-arrival} message to the downstream lending interface (keyed by $t$),
  \item and advances the durable input cursor $K_s$ for the consumed $\mathsf{CLIENT\_TRADE}_s(t)$ input record.
\end{enumerate}
Formally, the shard state update is:
\[
Tr_s' = Tr_s \cup \{t\}.
\]

\textbf{Downstream Interface Assumption (recommended):} The lending system \emph{should} process trade-arrival messages idempotently by trade identifier $t$ so that any retries outside the transactional boundary are harmless.

\textbf{Note:} The trade's total quantity $qty^{tot}(t)$ is immutable and recorded when the trade is added. Initially, $qty^{alloc}(t)=0$ and $qty^{open}(t)=qty^{tot}(t)$.

\subsubsection{Allocation (Pluggable, Partial)}

This is the core transition where settled flow is allocated to client trades:
\[
\sigma_s \xrightarrow{\mathsf{ALLOCATE}_s}_s \sigma_s'
\]

\textbf{Allocation Strategy Operator Invocation:} Define the open-demand vector over current shard trades:
\[
open_s(t)\triangleq qty^{open}(t)\ (t\in Tr_s),
\qquad
Open_s \in \mathbb{Z}^{Tr_s}.
\]
The system invokes the allocation operator (Section~\ref{sec:alloc-operator}):
\[
X \triangleq \mathcal{F}_{s,\Theta_s}(Tr_s,\ Open_s,\ U_s),
\qquad
X \in \mathbb{Z}^{Tr_s},
\]
where each component $X_t$ is the signed quantity allocated to trade $t$.

\textbf{Feasibility Constraints:} Let $d \triangleq \sgn(U_s)$.
If $d=0$, then $X_t=0$ for all $t$.
Otherwise the plan must satisfy:
\[
\forall t\in Tr_s:\ 
\begin{cases}
X_t = 0, & \text{if } \sgn(open_s(t))\neq d,\\
0 \le d\cdot X_t \le d\cdot open_s(t), & \text{if } \sgn(open_s(t))=d,
\end{cases}
\]
and the total must respect available carry:
\[
0 \le d\cdot \sum_{t\in Tr_s} X_t \le d\cdot U_s \ (=|U_s|).
\]
Intuitively, receive-side carry ($U_s>0$) is allocated only to receive-open trades, and deliver-side carry ($U_s<0$) only to deliver-open trades.

\textbf{Processing for Nonzero Allocations:} For each trade $t$ with $X_t\neq 0$, the system:
\begin{enumerate}[leftmargin=*,topsep=0.25em,itemsep=0.15em]
  \item Generates a fresh allocation identifier $id_t\in ID_s$
  \item Adds $(id_t,t,X_t)$ to the allocation ledger $A_s$
  \item Increments $qty^{alloc}(t)$ by $X_t$
  \item Sets publication status $P_s(id_t)=\mathsf{pending}$
\end{enumerate}

\textbf{Carry Update:} The total allocated quantity is deducted from unallocated carry:
\[
U_s' = U_s - \sum_{t\in Tr_s} X_t.
\]

\textbf{Partial Allocation Behavior:} The operator may allocate zero to some or all trades. If $X_t=0$ for all $t$, then $U_s$ remains unchanged, representing explicit carry forward. This supports partial settlements on either side.

\subsubsection{Exactly-Once Publication to Lending}

Allocations must be communicated to downstream lending systems:
\[
\sigma_s \xrightarrow{\mathsf{PUBLISH}_s(id)}_s \sigma_s'
\qquad
(P_s(id)=\mathsf{pending})
\]

\textbf{Precondition:} The allocation $id$ must be in pending state.

\textbf{Processing (atomic publication):} Within a single atomic transaction, the system:
\begin{enumerate}[leftmargin=*,topsep=0.25em,itemsep=0.15em]
  \item persists the transition that marks the allocation as published,
  \item emits the corresponding allocation message to the downstream lending interface,
  \item and advances the durable input cursor $K_s$ for the consumed $\mathsf{PUBLISH}_s(id)$ trigger record.
\end{enumerate}
Formally, the shard state update is:
\[
P_s'(id)=\mathsf{published}.
\]

\textbf{Downstream Interface Assumption (recommended):} The lending system \emph{should} process allocations idempotently by allocation identifier $id$. This makes retries safe in the presence of transient delivery failures outside the transactional boundary.

\subsubsection{End-of-Day Reconciliation}

At end of day, the system reconciles its internal state with CNS obligations:
\[
\sigma_s \xrightarrow{\mathsf{EOD\_RECON}_s}_s \sigma_s'
\]

\textbf{Discrepancy Calculation:} Compute the signed difference between CNS and the system's tracked decomposition:
\[
\epsilon_s \triangleq O_s - (Need_s + U_s).
\]
Here $O_s$ is CNS net open obligation, while $(Need_s + U_s)$ is the system's net open trade demand plus unallocated carry.

\textbf{Processing:} The discrepancy $\epsilon_s$ is recorded externally (e.g., in a break table for investigation). The shard state itself remains unchanged:
\[
\sigma_s' = \sigma_s.
\]

\textbf{Interpretation:} Under normal operation, $\epsilon_s$ should be $0$. A nonzero $\epsilon_s$ indicates a reconciliation break; its sign indicates the direction of the net mismatch.

\subsubsection{Crash and Restart}

The system must survive crashes without losing consistency:

\textbf{Crash Transition:}
\[
\sigma_s \xrightarrow{\mathsf{CRASH}_s}_s \bot_s.
\]
The $\bot_s$ state represents a crashed shard where durable state survives but volatile runtime state is lost.

\textbf{Restart Transition:}
\[
\bot_s \xrightarrow{\mathsf{RESTART}_s}_s \sigma_s'.
\]

\textbf{Recovery Model:} On restart, the shard restores the last \emph{committed} persistent state $(O_s,Tr_s,A_s,U_s,P_s,K_s)$. Processing resumes from the durable message log at position $K_s+1$. Any in-flight (uncommitted) transition at the time of crash is rolled back (i.e., has no visible effect), and its input record is eligible for reprocessing.

\subsection{Allocation Strategy as an Operator}
\label{sec:alloc-operator}

For a fixed security $s$, define the open-demand vector over shard trades:
\[
open_s(t)\triangleq qty^{open}(t)\ \ (t\in Tr_s),
\qquad
Open_s \in \mathbb{Z}^{Tr_s}.
\]

We model the pluggable allocation strategy as an operator that produces an allocation plan:
\[
\mathcal{F}_{s,\Theta}:\ (Tr_s,\ Open_s,\ U_s)\ \to\ X \in \mathbb{Z}^{Tr_s}.
\]
(Equivalently, $\mathcal{F}_{s,\Theta}$ may be treated as a relation to allow multiple admissible plans.)

\paragraph{Core operator properties.}
For any output plan
\hfill\break
$X=\mathcal{F}_{s,\Theta}(Tr_s,Open_s,U_s)$, let $d\triangleq \sgn(U_s)$:
\begin{enumerate}[leftmargin=*]
  \item \khead{Feasibility:}
  if $d=0$ then $X_t=0$ for all $t$; otherwise for all $t\in Tr_s$,
  \[
  \begin{aligned}
  \sgn(open_s(t))\neq d &\Rightarrow X_t=0,
  \qquad \\
  \sgn(open_s(t))=d &\Rightarrow 0 \le d\cdot X_t \le d\cdot open_s(t),
  \end{aligned}
  \]
  and
  \[
  0 \le d\cdot \sum_{t\in Tr_s} X_t \le d\cdot U_s \ (=|U_s|).
  \]
  \item \khead{Eligibility compliance:}
  if $\neg eligible_s(t)$ then $X_t=0$.
  \item \khead{Work-conserving:}
\hfill\break
  if $U_s\neq 0$ and $\exists t: eligible_s(t)\wedge \sgn(open_s(t))=\sgn(U_s)$ then $\sum_t X_t\neq 0$.
\end{enumerate}

% ===================== CONCURRENCY =====================
\section{Concurrency Properties Induced by Partitioning}
\label{sec:concurrency}

\begin{proposition}[Cross-Shard Commutativity]
If $key(e_1)\neq key(e_2)$ then the events commute:
\[
(\sigma \xrightarrow{e_1} \sigma_1 \xrightarrow{e_2} \sigma_{12})
\Rightarrow
(\sigma \xrightarrow{e_2} \sigma_2 \xrightarrow{e_1} \sigma_{21})
\wedge
\sigma_{12}=\sigma_{21}.
\]
\end{proposition}

\begin{proof}[Proof sketch]
By definition of the global transition relation, each event updates only its keyed shard and leaves all other shards unchanged.
\end{proof}

% ===================== SAFETY =====================
\section{Safety Properties}
\label{sec:safety}

\begin{proposition}[No Over-Allocation]
For all trades $t$ in any reachable state:
\[
qty^{alloc}(t)\cdot qty^{tot}(t)\ge 0
\quad\wedge\quad
|qty^{alloc}(t)| \le |qty^{tot}(t)|.
\]
\end{proposition}

\begin{proof}[Proof sketch]
Only allocation changes $qty^{alloc}(t)$, and feasibility enforces that allocations have the same sign as open demand and do not exceed it in magnitude, hence cannot exceed $|qty^{tot}(t)|$.
\end{proof}

\begin{proposition}[Allocation Never Exceeds Carry]
In any $\mathsf{ALLOCATE}_s$ transition with pre-state carry $U_s$, the chosen plan $X$ satisfies
\[
\left|\sum_{t\in Tr_s} X_t\right| \le |U_s|
\quad\text{and}\quad
\sgn\!\left(\sum_{t\in Tr_s} X_t\right)\in\{0,\sgn(U_s)\}.
\]
\end{proposition}

\begin{proof}[Proof sketch]
Immediate from the feasibility constraint $0 \le d\cdot \sum_t X_t \le d\cdot U_s$ with $d=\sgn(U_s)$.
\end{proof}

\begin{proposition}[Allocation Conservation]
For each $s$, allocations are bounded by cumulative settled flow implied by CNS updates: carry evolves as
$U_s := U_s + \Delta settle(s)$ on CNS updates and $U_s := U_s - \sum_t X_t$ on allocations, so total allocated
flow cannot exceed the cumulative settled flow on either side.
\end{proposition}

\begin{proof}[Proof sketch]
By construction, carry is the residual between cumulative settled flow and cumulative allocated flow; feasibility prevents allocating more than the current residual magnitude.
\end{proof}

% ===================== EXACTLY ONCE =====================
\section{Exactly-Once Publication and Crash Recovery}
\label{sec:exactly-once}

\begin{proposition}[At-Most-Once Publication in the Model]
For any $id\in ID_s$, $\mathsf{PUBLISH}_s(id)$ transitions the state from $\mathsf{pending}$ to $\mathsf{published}$ and never reverses.
\end{proposition}

\begin{proof}[Proof sketch]
Publishing updates $P_s(id)$ monotonically from pending to published.
\end{proof}

\begin{proposition}[Crash-Safe Publication State]
If $P_s(id)=\mathsf{published}$ before a crash, then after restart $P_s(id)=\mathsf{published}$.
\end{proposition}

\begin{proof}[Proof sketch]
$P_s$ is persistent. By the transactional discipline, once the published state is committed it survives crashes.
\end{proof}

\begin{proposition}[No Lost Allocations Across Crash]
\hfill\break
If $(id,t,q)\in A_s$ before a crash, then $(id,t,q)\in A_s$ after restart.
\end{proposition}

\begin{proof}[Proof sketch]
$A_s$ is persistent; committed allocations survive crashes.
\end{proof}

\begin{proposition}[Exactly-Once Downstream Effect]
Under the transactional discipline (atomic state update + downstream publication + cursor advance), each allocation publication has exactly-once downstream effect under retries despite crashes. If the downstream lending system is additionally idempotent on allocation identifier $id$, the guarantee remains robust even if delivery retries occur outside the transaction boundary.
\end{proposition}

\begin{proof}[Proof sketch]
At-most-once: a committed publication advances the cursor and marks $P_s(id)=\mathsf{published}$, so reprocessing the same trigger cannot re-emit a committed publication.
At-least-once: if a crash happens before commit, the cursor does not advance and the trigger is reprocessed after restart, leading to eventual publication.
Downstream idempotence makes any residual duplicate deliveries harmless.
\end{proof}

% ===================== FAIRNESS =====================
\section{Fairness for Partial Settlements}
\label{sec:fairness}

\subsection{Eligibility}

Define an eligibility predicate (parameterized by $\Theta_s$):
\[
eligible_s(t) \triangleq (t\in Tr_s)\ \wedge\ (qty^{open}(t)\neq 0)\ \wedge\ \mathsf{ExtraElig}_s(t,\Theta_s).
\]

\subsection{Weak Fairness}

Assume weak fairness per security: if $eligible_s(t)\wedge U_s\neq 0 \wedge \sgn(qty^{open}(t))=\sgn(U_s)$ holds continuously over an infinite suffix, then there exist infinitely many allocation steps where $X_t\neq 0$.

\begin{proposition}[No Starvation Under Persistent Same-Side Supply]
No eligible trade with persistent same-side carry is starved indefinitely.
\end{proposition}

\begin{proof}[Proof sketch]
Immediate from weak fairness.
\end{proof}

% ===================== RECONCILIATION =====================
\section{End-of-Day Reconciliation Convergence}
\label{sec:reconciliation}

\paragraph{Per-Security Reconciliation Equation.}
At end-of-day for each $s$:
\[
O_s = Need_s + U_s + \epsilon_s,
\]
where $\epsilon_s$ is an explicitly recorded signed discrepancy.

\begin{proposition}[Crash-Resilient Convergence Under Stabilization]
Assume: (i) CNS obligations stabilize by EOD, (ii) there exists a time after which no new trades arrive,
(iii) enabled allocation and publish actions are retried indefinitely, (iv) the allocation strategy is weakly fair,
and (v) only finitely many crashes occur. Then for each security $s$ the system reaches a state with
\[
\epsilon_s=0
\quad\text{and}\quad
O_s=Need_s+U_s.
\]
\end{proposition}

\begin{proof}[Proof sketch]
After stabilization, $O_s$ is constant so $U_s$ stops changing due to CNS inputs. With no new trades, progress comes only from allocation.
While $U_s\neq 0$ and there exist same-side open trades ($\exists t:\ qty^{open}(t)\neq 0 \wedge \sgn(qty^{open}(t))=\sgn(U_s)$),
weak fairness yields allocations that reduce same-side open demand toward $0$ until either same-side demand is exhausted or $U_s$ reaches $0$,
implying $\epsilon_s=0$. Crashes do not erase committed progress because persistent state and the durable cursor restore the shard to its last committed point.
\end{proof}

% ===================== IMPLEMENTATION =====================
\section{Implementation Notes (Non-Normative)}

Each security $s$ can be implemented as a shard with:
\begin{itemize}[leftmargin=*]
  \item a durable state store for $(O_s,Tr_s,A_s,U_s,P_s)$,
  \item a \kfeat{durable ordered message log} providing per-security input streams and a \kfeat{durable cursor} $K_s$,
  \item a \kfeat{transactional processing engine} that commits \emph{atomically}: (i) state updates, (ii) downstream publication (or an outbox/outbound stream append), and (iii) cursor advancement,
  \item a \kfeat{strategy plugin} implementing the operator $\mathcal{F}_{s,\Theta_s}$,
  \item a publisher that retries \kfeat{pending allocations} until \kfeat{published}.
\end{itemize}

\end{document}
